// Copyright (c) 2013, 2014 Masato Hagiwara
// https://github.com/mhagiwara/camxes.js
// Copyright (c) 2018 John Gietzen
// This source is subject to the MIT license. Please see license.md for more information.
// Originally from http://users.digitalkingdom.org/~rlpowell/hobbies/lojban/grammar/index.html
@namespace LojbanParser
@classname LojbanGrammer
@using System.Linq;
@members
{
    private static string _join(IEnumerable<object> items)
    {
        return string.Concat(items);
    }

    private static string _join(string value)
    {
        return value;
    }
}

text <object> -lexical = intro:intro_null nai:NAI_clause* textA:text_part_2 joik:(<object> !text_1 j:joik_jek { j })? textB:text_1? faho:faho_clause EOF? { new { label = "text", arg = new[] { intro }.Concat(nai).Concat(new[] { textA }).Concat(joik).Concat(textB).Concat(new[] { faho }).ToArray() } }

intro_null <object> = pre:(<object[]> a:spaces? b:su_clause* { a.Concat(b).ToArray() }) arg:intro_si_clause { new { label = "intro_null", pre, arg } }

text_part_2 <object> = expr:((CMENE_clause+ / indicators?) free*) { new { label = "text_part_2", arg = expr } }

intro_si_clause <object> = a:si_clause? b:SI_clause* { new { label = "intro_si_clause", arg = a.Concat(b).ToArray() } }

faho_clause <object> = expr:(FAhO_clause dot_star)? { new { label = "faho_clause", arg = expr } }

text_1 <object> -memoize = expr:(<object> I_clause (jek / joik)? (stag? BO_clause)? free* text_1? / NIhO_clause+ free* su_clause* paragraphs? / paragraphs) { new { label = "text_1", arg = expr } }

paragraphs <object> = arg:paragraphs_inner { new { label = "paragraphs", arg } }

paragraphs_inner <object[]> = p:paragraph delimit:(<object[]> niho:NIhO_clause+ free:free* su:su_clause* rest:paragraphs_inner { new[] { niho }.Concat(free).Concat(su).Concat(rest).ToArray() })? { new[] { p }.Concat(delimit.SelectMany(d => d)).ToArray() }

paragraph <object> -memoize = arg:paragraph_inner { new { label = "paragraph", arg } }

paragraph_inner <object[]> = s:(statement / fragment) delimit:(<object[]> i:I_clause !jek !joik !joik_jek free:free* rest:paragraph_inner { new[] { i }.Concat(free).Concat(rest).ToArray() })?  { new[] { s }.Concat(delimit.SelectMany(d => d)).ToArray() }

statement <object>
    = arg:statement_1 { new { label = "statement", arg } }
    / pre:prenex arg:statement { new { label = "statement", pre, arg } }

statement_1 <object>
    = s:statement_2 rest:(<object[]> i:I_clause j:joik_jek s2:statement_2? { new[] { i, j }.Concat(s2).ToArray() })* { new { label = "statement_1", arg = new[] { s }.Concat(rest.SelectMany(x => x)) } }

statement_2 <object>
    = s:statement_3 rest:(<object[]> i:I_clause j:(jek / joik)? st:stag? bo:BO_clause f:free* s2:statement_2? { new[] { i }.Concat(j).Concat(st).Concat(new[] { bo }).Concat(f).Concat(s2).ToArray() })? { new { label = "statement_2", arg = new[] { s }.Concat(rest.SelectMany(x => x)) } }

statement_3 <object>
    = arg:sentence { new { label = "statement_3", arg } }
    / tag:tag? tuhe:TUhE_clause f1:free* text:text_1 tuhu:TUhU_clause? f2:free* { new { label = "statement_3", arg = tag.Concat(new[] { tuhe }).Concat(f1).Concat(new [] { text }).Concat(tuhu).Concat(f1).ToArray() } }

fragment <object> = expr:(prenex / terms VAU_clause? free* / ek free* / gihek free* / quantifier / NA_clause !JA_clause free* / relative_clauses / links / linkargs) { new { label = "fragment", arg = expr } }

prenex <object> = expr:(terms ZOhU_clause free*) { new { label = "prenex", arg = expr } }

sentence <object> = pre:(<object[]> t:terms b1:bridi_tail_sa* cu:CU_clause? f:free* { new[] { t }.Concat(b1).Concat(cu).Concat(f).ToArray() })? b2:bridi_tail_sa* tail:bridi_tail { new { label = "sentence", arg = pre.SelectMany(x => x).Concat(b2).Concat(new [] { tail }).ToArray() } }

sentence_sa <object> = expr:(sentence_start (!sentence_start (sa_word / SA_clause !sentence_start ) )* SA_clause &text_1) { new { label = "sentence_sa", arg = expr } }

sentence_start <object> = arg:(I_pre / NIhO_pre) { new { label = "sentence_start", arg } }

subsentence <object>
    = arg:sentence { new { label = "subsentence", arg } }
    / pre:prenex arg:subsentence { new { label = "subsentence", pre, arg } }

bridi_tail <object> -memoize = expr:(bridi_tail_1 (gihek stag? KE_clause free* bridi_tail KEhE_clause? free* tail_terms)?) { new { label = "bridi_tail", arg = expr } }

bridi_tail_sa <object> = expr:(bridi_tail_start (term / !bridi_tail_start (sa_word / SA_clause !bridi_tail_start ) )* SA_clause &bridi_tail) { new { label = "bridi_tail_sa", arg = expr } }

bridi_tail_start <object> = expr:(ME_clause / NUhA_clause / NU_clause / NA_clause !KU_clause / NAhE_clause !BO_clause / selbri / tag bridi_tail_start / KE_clause bridi_tail_start / bridi_tail) { new { label = "bridi_tail_start", arg = expr } }

bridi_tail_1 <object> = expr:(bridi_tail_2 (gihek !(stag? BO_clause) !(stag? KE_clause) free* bridi_tail_2 tail_terms)*) { new { label = "bridi_tail_1", arg = expr } }

bridi_tail_2 <object> = expr:(bridi_tail_3 (gihek stag? BO_clause free* bridi_tail_2 tail_terms)?) { new { label = "bridi_tail_2", arg = expr } }

bridi_tail_3 <object> = expr:(<object> s:selbri t:tail_terms { new { selbri = s, trail_terms = t } } / gek_sentence) { new { label = "bridi_tail_3", arg = expr } }

gek_sentence <object> = expr:(gek subsentence gik subsentence tail_terms / tag? KE_clause free* gek_sentence KEhE_clause? free* / NA_clause free* gek_sentence) { new { label = "gek_sentence", arg = expr } }

tail_terms <object> = expr:(terms? VAU_clause? free*) { expr == null ? null : new { label = "tail_terms", arg = expr } }

terms <object> = arg:terms_1+ { new { label = "terms", arg } }

terms_1 <object> = expr:(terms_2 (pehe_sa* PEhE_clause free* joik_jek terms_2)*) { new { label = "terms_1", arg = expr } }

terms_2 <object> = expr:(term (cehe_sa* CEhE_clause free* term)*) { new { label = "terms_2", arg = expr } }

pehe_sa <object> = expr:(PEhE_clause (!PEhE_clause (sa_word / SA_clause !PEhE_clause))* SA_clause) { new { label = "pehe_sa", arg = expr } }

cehe_sa <object> = expr:(CEhE_clause (!CEhE_clause (sa_word / SA_clause !CEhE_clause))* SA_clause) { new { label = "cehe_sa", arg = expr } }

term <object> = expr:(term_sa* term_1) { new { label = "term", arg = expr } }

term_1 <object> = expr:(sumti / ( !gek (tag / FA_clause free*) (sumti / KU_clause? free*) ) / termset / NA_clause KU_clause free*) { new { label = "term_1", arg = expr } }

term_sa <object> = expr:(term_start (!term_start (sa_word / SA_clause !term_start ) )* SA_clause &term_1) { new { label = "term_sa", arg = expr } }

term_start <object> = expr:(term_1 / LA_clause / LE_clause / LI_clause / LU_clause / LAhE_clause / quantifier term_start / gek sumti gik / FA_clause / tag term_start) { new { label = "term_start", arg = expr } }

termset <object> = termset:(gek_termset / NUhI_clause free* gek terms NUhU_clause? free* gik terms NUhU_clause? free* / NUhI_clause free* terms NUhU_clause? free*) { new { label = "termset", arg = termset } }

gek_termset <object> = expr:(gek terms_gik_terms) { new { label = "gek_termset", arg = expr } }

terms_gik_terms <object> = expr:(term (gik / terms_gik_terms) term) { new { label = "terms_gik_terms", arg = expr } }

sumti <object> = expr:(sumti_1 (VUhO_clause free* relative_clauses)?) { new { label = "sumti", arg = expr } }

sumti_1 <object> = expr:(sumti_2 (joik_ek stag? KE_clause free* sumti KEhE_clause? free*)?) { new { label = "sumti_1", arg = expr } }

sumti_2 <object> = expr:(sumti_3 (joik_ek sumti_3)*) { new { label = "sumti_2", arg = expr } }

sumti_3 <object> = expr:(sumti_4 (joik_ek stag? BO_clause free* sumti_3)?) { new { label = "sumti_3", arg = expr } }

sumti_4 <object> = expr:(sumti_5 / gek sumti gik sumti_4) { new { label = "sumti_4", arg = expr } }

sumti_5 <object> = expr:(quantifier? sumti_6 relative_clauses? / quantifier selbri KU_clause? free* relative_clauses?) { new { label = "sumti_5", arg = expr } }

sumti_6 <object> = expr:(<object> ZO_clause free* / ZOI_clause free* / LOhU_clause free* / lerfu_string !MOI_clause BOI_clause? free* / LU_clause text LIhU_clause? free* / (LAhE_clause free* / NAhE_clause BO_clause free*) relative_clauses? sumti LUhU_clause? free* / KOhA_clause free* / LA_clause free* relative_clauses? CMENE_clause+ free* / (LA_clause / LE_clause) free* sumti_tail KU_clause? free* / li_clause) { new { label = "sumti_6", arg = expr } }

li_clause <object> = expr:(LI_clause free* mex LOhO_clause? free*) { new { label = "li_clause", arg = expr } }

sumti_tail <object> -memoize = expr:((sumti_6 relative_clauses?)? sumti_tail_1 / relative_clauses sumti_tail_1) { new { label = "sumti_tail", arg = expr } }

sumti_tail_1 <object> = expr:(selbri relative_clauses? / quantifier selbri relative_clauses? / quantifier sumti) { new { label = "sumti_tail_1", arg = expr } }

relative_clauses <object> = expr:(relative_clause (ZIhE_clause free* relative_clause)*) { new { label = "relative_clauses", arg = expr } }

// relative_clause = GOI_clause free* term GEhU_clause? free* / NOI_clause free* subsentence KUhO_clause? free*

relative_clause <object> = expr:(relative_clause_sa* relative_clause_1) { new { label = "relative_clause", arg = expr } }

relative_clause_sa <object> = expr:(relative_clause_start (!relative_clause_start (sa_word / SA_clause !relative_clause_start ) )* SA_clause &relative_clause_1) { new { label = "relative_clause_sa", arg = expr } }

relative_clause_1 <object> = expr:(GOI_clause free* term GEhU_clause? free* / NOI_clause free* subsentence KUhO_clause? free* ) { new { label = "relative_clause_1", arg = expr } }

relative_clause_start <object> = expr:(GOI_clause / NOI_clause) { new { label = "relative_clause_start", arg = expr } }

selbri <object> = expr:(tag? selbri_1) { new { label = "selbri", arg = expr } }

selbri_1 <object> = expr:(selbri_2 / NA_clause free* selbri) { new { label = "selbri_1", arg = expr } }

selbri_2 <object> = expr:(selbri_3 (CO_clause free* selbri_2)?) { new { label = "selbri_2", arg = expr } }

selbri_3 <object> = expr:(selbri_4+) { new { label = "selbri_3", arg = expr } }

selbri_4 <object> = expr:(selbri_5 (joik_jek selbri_5 / joik stag? KE_clause free* selbri_3 KEhE_clause? free*)*) { new { label = "selbri_4", arg = expr } }

selbri_5 <object> = expr:(selbri_6 ((jek / joik) stag? BO_clause free* selbri_5)?) { new { label = "selbri_5", arg = expr } }

selbri_6 <object> = expr:(tanru_unit (BO_clause free* selbri_6)? / NAhE_clause? free* guhek selbri gik selbri_6) { new { label = "selbri_6", arg = expr } }

tanru_unit <object> = expr:(tanru_unit_1 (CEI_clause free* tanru_unit_1)*) { new { label = "tanru_unit", arg = expr } }

tanru_unit_1 <object> = expr:(tanru_unit_2 linkargs?) { new { label = "tanru_unit_1", arg = expr } }

// ** zei is part of BRIVLA_clause
tanru_unit_2 <object> = expr:(BRIVLA_clause free* / GOhA_clause RAhO_clause? free* / KE_clause free* selbri_3 KEhE_clause? free* / ME_clause free* (sumti / lerfu_string) MEhU_clause? free* MOI_clause? free* / (number / lerfu_string) MOI_clause free* / NUhA_clause free* mex_operator / SE_clause free* tanru_unit_2 / JAI_clause free* tag? tanru_unit_2 / NAhE_clause free* tanru_unit_2 / NU_clause NAI_clause? free* (joik_jek NU_clause NAI_clause? free*)* subsentence KEI_clause? free*) { new { label = "tanru_unit_2", arg = expr } }

linkargs <object> = expr:(linkargs_sa* linkargs_1)  { new { label = "linkargs", arg = expr } }

linkargs_1 <object> = expr:(BE_clause free* term links? BEhO_clause? free*)  { new { label = "linkargs_1", arg = expr } }

linkargs_sa <object> = expr:(linkargs_start (!linkargs_start (sa_word / SA_clause !linkargs_start ) )* SA_clause &linkargs_1) { new { label = "linkargs_sa", arg = expr } }

linkargs_start <object> = expr:BE_clause { new { label = "linkargs_start", arg = expr } }

links <object> = expr:(links_sa* links_1) { new { label = "links", arg = expr } }

links_1 <object> = expr:(BEI_clause free* term links?) { new { label = "links_1", arg = expr } }

links_sa <object> = expr:(links_start (!links_start (sa_word / SA_clause !links_start ) )* SA_clause &links_1) { new { label = "links_sa", arg = expr } }

links_start <object> = expr:(BEI_clause) { new { label = "links_start", arg = expr } }

quantifier <object> = expr:(number !MOI_clause BOI_clause? free* / VEI_clause free* mex VEhO_clause? free*) { new { label = "quantifier", arg = expr } }

// mex = mex_1 (operator mex_1)* / rp_clause

mex <object> = expr:(mex_sa* mex_0) { new { label = "mex", arg = expr } }

mex_0 <object> = expr:(<object> mex_1 (operator mex_1)* / rp_clause) { new { label = "mex_0", arg = expr } }

mex_sa <object> = expr:(mex_start (!mex_start (sa_word / SA_clause !mex_start) )* SA_clause &mex_0) { new { label = "mex_sa", arg = expr } }

mex_start <object> = expr:(FUhA_clause / PEhO_clause / operand_start) { new { label = "mex_start", arg = expr } }

rp_clause <object> = expr:(FUhA_clause free* rp_expression) { new { label = "rp_clause", arg = expr } }

mex_1 <object> = expr:(mex_2 (BIhE_clause free* operator mex_1)?) { new { label = "mex_1", arg = expr } }

mex_2 <object> = expr:(operand / mex_forethought) { new { label = "mex_2", arg = expr } }

// This is just to make for clearer parse trees
mex_forethought = PEhO_clause? free* operator fore_operands KUhE_clause? free*
fore_operands <object> = expr:(mex_2+ ) { new { label = "fore_operands", arg = expr } }

//li fu'a reboi ci pi'i voboi mu pi'i su'i reboi ci vu'u su'i du li rexa
//rp_expression = rp_operand rp_operand operator
//rp_operand = operand / rp_expression
// AKA (almost; this one allows a single operand; above does not.
//rp_expression = rp_expression rp_expression operator / operand

// Right recursive version.
rp_expression <object> = expr:(operand rp_expression_tail) { new { label = "rp_expression", arg = expr } }
rp_expression_tail <object> = expr:(rp_expression operator rp_expression_tail / ()) { new { label = "rp_expression_tail", arg = expr } }

operator <object> = expr:(operator_sa* operator_0) { new { label = "operator", arg = expr } }

operator_0 <object> = expr:(operator_1 (joik_jek operator_1 / joik stag? KE_clause free* operator KEhE_clause? free*)*) { new { label = "operator_0", arg = expr } }

operator_sa <object> = expr:(operator_start (!operator_start (sa_word / SA_clause !operator_start) )* SA_clause &operator_0) { new { label = "operator_sa", arg = expr } }

operator_start <object> = expr:(guhek / KE_clause / SE_clause? NAhE_clause / SE_clause? MAhO_clause / SE_clause? VUhU_clause) { new { label = "operator_start", arg = expr } }

operator_1 <object> = expr:(operator_2 / guhek operator_1 gik operator_2 / operator_2 (jek / joik) stag? BO_clause free* operator_1) { new { label = "operator_1", arg = expr } }

operator_2 <object> = expr:(mex_operator / KE_clause free* operator KEhE_clause? free*) { new { label = "operator_2", arg = expr } }

mex_operator <object> = expr:(SE_clause free* mex_operator / NAhE_clause free* mex_operator / MAhO_clause free* mex TEhU_clause? free* / NAhU_clause free* selbri TEhU_clause? free* / VUhU_clause free*) { new { label = "mex_operator", arg = expr } }

operand <object> = expr:(operand_sa* operand_0) { new { label = "operand", arg = expr } }

operand_0 <object> = expr:(operand_1 (joik_ek stag? KE_clause free* operand KEhE_clause? free*)?) { new { label = "operand_0", arg = expr } }

operand_sa <object> = expr:(operand_start (!operand_start (sa_word / SA_clause !operand_start) )* SA_clause &operand_0) { new { label = "operand_sa", arg = expr } }

operand_start <object> = expr:(quantifier / lerfu_word / NIhE_clause / MOhE_clause / JOhI_clause / gek / LAhE_clause / NAhE_clause) { new { label = "operand_start", arg = expr } }

operand_1 <object> = expr:(operand_2 (joik_ek operand_2)*) { new { label = "operand_1", arg = expr } }

operand_2 <object> = expr:(operand_3 (joik_ek stag? BO_clause free* operand_2)?) { new { label = "operand_2", arg = expr } }

operand_3 <object> = expr:(quantifier / lerfu_string !MOI_clause BOI_clause? free* / NIhE_clause free* selbri TEhU_clause? free* / MOhE_clause free* sumti TEhU_clause? free* / JOhI_clause free* mex_2+ TEhU_clause? free* / gek operand gik operand_3 / (LAhE_clause free* / NAhE_clause BO_clause free*) operand LUhU_clause? free*) { new { label = "operand_3", arg = expr } }

number <object> = expr:(PA_clause (PA_clause / lerfu_word)*) { new { label = "number", arg = expr } }

lerfu_string <object> = expr:(lerfu_word (PA_clause / lerfu_word)*) { new { label = "lerfu_string", arg = expr } }

// ** BU clauses are part of BY_clause
lerfu_word <object> = expr:(BY_clause / LAU_clause lerfu_word / TEI_clause lerfu_string FOI_clause) { new { label = "lerfu_word", arg = expr } }

ek <object> = expr:(NA_clause? SE_clause? A_clause NAI_clause?) { new { label = "ek", arg = expr } }

gihek <object> = expr:(gihek_sa* gihek_1) { new { label = "gihek", arg = expr } }

gihek_1 <object> = expr:(NA_clause? SE_clause? GIhA_clause NAI_clause?) { new { label = "gihek_1", arg = expr } }

gihek_sa <object> = expr:(gihek_1 (!gihek_1 (sa_word / SA_clause !gihek_1 ) )* SA_clause &gihek) { new { label = "gihek_sa", arg = expr } }

jek <object> = expr:(NA_clause? SE_clause? JA_clause NAI_clause?) { new { label = "jek", arg = expr } }

joik <object> = expr:(<object> SE_clause? JOI_clause NAI_clause? / interval / GAhO_clause interval GAhO_clause) { new { label = "joik", arg = expr } }

interval <object> = expr:(SE_clause? BIhI_clause NAI_clause?) { new { label = "interval", arg = expr } }

joik_ek <object> = expr:(joik_ek_sa* joik_ek_1) { new { label = "joik_ek", arg = expr } }

joik_ek_1 <object> = expr:((joik free* / ek free*)) { new { label = "joik_ek_1", arg = expr } }

joik_ek_sa <object> = expr:(joik_ek_1 (!joik_ek_1 (sa_word / SA_clause !joik_ek_1 ) )* SA_clause &joik_ek) { new { label = "joik_ek_sa", arg = expr } }

joik_jek <object> = expr:(joik free* / jek free*) { new { label = "joik_jek", arg = expr } }

gek <object> = expr:(SE_clause? GA_clause NAI_clause? free* / joik GI_clause free* / stag gik) { new { label = "gek", arg = expr } }

guhek <object> = expr:(SE_clause? GUhA_clause NAI_clause? free*) { new { label = "guhek", arg = expr } }

gik <object> = expr:(GI_clause NAI_clause? free*) { new { label = "gik", arg = expr } }

tag <object> = expr:(tense_modal (joik_jek tense_modal)*) { new { label = "tag", arg = expr } }

stag <object> = expr:(simple_tense_modal ((jek / joik) simple_tense_modal)* / tense_modal (joik_jek tense_modal)*) { new { label = "stag", arg = expr } }

tense_modal <object> = expr:(simple_tense_modal free* / FIhO_clause free* selbri FEhU_clause? free*) { new { label = "tense_modal", arg = expr } }

simple_tense_modal <object> = expr:(<object> NAhE_clause? SE_clause? BAI_clause NAI_clause? KI_clause? / NAhE_clause? (<object> (<object> (time space? / space time?) CAhA_clause) / (time space? / space time?) / CAhA_clause ) KI_clause? / KI_clause / CUhE_clause) { new { label = "simple_tense_modal", arg = expr } }

time <object> = expr:(ZI_clause time_offset* (ZEhA_clause (PU_clause NAI_clause?)?)? interval_property* / ZI_clause? time_offset+ (ZEhA_clause (PU_clause NAI_clause?)?)? interval_property* / ZI_clause? time_offset* ZEhA_clause (PU_clause NAI_clause?)? interval_property* / ZI_clause? time_offset* (ZEhA_clause (PU_clause NAI_clause?)?)? interval_property+) { new { label = "time", arg = expr } }

time_offset <object> = expr:(PU_clause NAI_clause? ZI_clause?) { new { label = "time_offset", arg = expr } }

space <object> = expr:(VA_clause space_offset* space_interval? (MOhI_clause space_offset)? / VA_clause? space_offset+ space_interval? (MOhI_clause space_offset)? / VA_clause? space_offset* space_interval (MOhI_clause space_offset)? / VA_clause? space_offset* space_interval? MOhI_clause space_offset) { new { label = "space", arg = expr } }

space_offset <object> = expr:(FAhA_clause NAI_clause? VA_clause?) { new { label = "space_offset", arg = expr } }

space_interval <object> = expr:(<object> (VEhA_clause / VIhA_clause / VEhA_clause VIhA_clause) (FAhA_clause NAI_clause?)? space_int_props / (VEhA_clause / VIhA_clause / VEhA_clause VIhA_clause) (FAhA_clause NAI_clause?)? / space_int_props) { new { label = "space_interval", arg = expr } }

space_int_props <object> = expr:((FEhE_clause interval_property)+) { new { label = "space_int_props", arg = expr } }

interval_property <object> = expr:(number ROI_clause NAI_clause? / TAhE_clause NAI_clause? / ZAhO_clause NAI_clause?) { new { label = "interval_property", arg = expr } }

free <object> = expr:(<object> SEI_clause free* (terms CU_clause? free*)? selbri SEhU_clause? / SOI_clause free* sumti sumti? SEhU_clause? / vocative relative_clauses? selbri relative_clauses? DOhU_clause? / vocative relative_clauses? CMENE_clause+ free* relative_clauses? DOhU_clause? / vocative sumti? DOhU_clause? / (number / lerfu_string) MAI_clause / TO_clause text TOI_clause? / xi_clause) { new { label = "free", arg = expr } }

xi_clause <object> = expr:(XI_clause free* (number / lerfu_string) BOI_clause? / XI_clause free* VEI_clause free* mex VEhO_clause?) { new { label = "xi_clause", arg = expr } }

vocative <object> = expr:(<object> (COI_clause NAI_clause?)+ DOI_clause / (COI_clause NAI_clause?) (COI_clause NAI_clause?)* / DOI_clause)  { new { label = "vocative", arg = expr } }

indicators <object> = expr:(FUhE_clause? indicator+) { new { label = "indicators", arg = expr } }

indicator <object> =  expr:(<object> (UI_clause / CAI_clause) NAI_clause? / DAhO_clause / FUhO_clause) !BU_clause { new { label = "indicator", arg = expr } }


// ****************
// Magic Words
// ****************

zei_clause <object> = pre:pre_clause arg:zei_clause_no_pre { new { label = "zei_clause", pre, arg } }
zei_clause_no_pre <object> = expr:(pre_zei_bu (zei_tail? bu_tail)* zei_tail post_clause) { new { label = "zei_clause_no_pre", arg = expr } }

bu_clause <object> -memoize = pre:pre_clause arg:bu_clause_no_pre { new { label = "bu_clause", pre, arg } }
bu_clause_no_pre <object> -memoize = expr:(pre_zei_bu (bu_tail? zei_tail)* bu_tail post_clause) { new { label = "bu_clause_no_pre", arg = expr } }

zei_tail <object> = expr:(ZEI_clause any_word)+ { new { label = "zei_tail", arg = expr } }
bu_tail <object> = expr:BU_clause+ { new { label = "bu_tail", arg = expr } }

pre_zei_bu <object> -memoize = expr:(!BU_clause !ZEI_clause !SI_clause !SA_clause !SU_clause !FAhO_clause any_word_SA_handling si_clause?) { new { label = "pre_zei_bu", arg = expr } }

dot_star = .*

// __ General Morphology Issues
//
// 1.  Spaces (including '.y') and UI are eaten *after* a word.
//
// 3.  BAhE is eaten *before* a word.

// Handling of what can go after a cmavo
post_clause <object> = a:spaces? b:si_clause? !ZEI_clause !BU_clause c:indicators* { new { label = "post_clause", arg = a.Concat(b).Concat(c).ToArray() } }

pre_clause -memoize = BAhE_clause?

any_word_SA_handling <object> -memoize = expr:(BRIVLA_pre / known_cmavo_SA / CMAVO_pre / CMENE_pre) { new { label = "any_word_SA_handling", arg = expr } }

known_cmavo_SA <object> = A_pre / BAI_pre / BAhE_pre / BE_pre / BEI_pre / BEhO_pre / BIhE_pre / BIhI_pre / BO_pre / BOI_pre / BU_pre / BY_pre / CAI_pre / CAhA_pre / CEI_pre / CEhE_pre / CO_pre / COI_pre / CU_pre / CUhE_pre / DAhO_pre / DOI_pre / DOhU_pre / FA_pre / FAhA_pre / FEhE_pre / FEhU_pre / FIhO_pre / FOI_pre / FUhA_pre / FUhE_pre / FUhO_pre / GA_pre / GAhO_pre / GEhU_pre / GI_pre / GIhA_pre / GOI_pre / GOhA_pre / GUhA_pre / I_pre / JA_pre / JAI_pre / JOI_pre / JOhI_pre / KE_pre / KEI_pre / KEhE_pre / KI_pre / KOhA_pre / KU_pre / KUhE_pre / KUhO_pre / LA_pre / LAU_pre / LAhE_pre / LE_pre / LEhU_pre / LI_pre / LIhU_pre / LOhO_pre / LOhU_pre / LU_pre / LUhU_pre / MAI_pre / MAhO_pre / ME_pre / MEhU_pre / MOI_pre / MOhE_pre / MOhI_pre / NA_pre / NAI_pre / NAhE_pre / NAhU_pre / NIhE_pre / NIhO_pre / NOI_pre / NU_pre / NUhA_pre / NUhI_pre / NUhU_pre / PA_pre / PEhE_pre / PEhO_pre / PU_pre / RAhO_pre / ROI_pre / SA_pre / SE_pre / SEI_pre / SEhU_pre / SI_clause / SOI_pre / SU_pre / TAhE_pre / TEI_pre / TEhU_pre / TO_pre / TOI_pre / TUhE_pre / TUhU_pre / UI_pre / VA_pre / VAU_pre / VEI_pre / VEhA_pre / VEhO_pre / VIhA_pre / VUhO_pre / VUhU_pre / XI_pre / ZAhO_pre / ZEI_pre / ZEhA_pre / ZI_pre / ZIhE_pre / ZO_pre / ZOI_pre / ZOhU_pre

// Handling of spaces and things like spaces.
// ___ SPACE ___

// SU clauses
su_clause <object> = pre:(erasable_clause / su_word)* arg:SU_clause { new { label = "su_clause", pre, arg } }

// Handling of SI and interactions with zo and lo'u...le'u

si_clause <object> -memoize = ((erasable_clause / si_word / SA_clause) si_clause? SI_clause)+

erasable_clause <object>
    = arg:bu_clause_no_pre !ZEI_clause !BU_clause { new { label = "erasable_clause", arg } }
    / arg:zei_clause_no_pre !ZEI_clause !BU_clause { new { label = "erasable_clause", arg } }

sa_word = pre_zei_bu

si_word = pre_zei_bu

su_word <object> = !NIhO_clause !LU_clause !TUhE_clause !TO_clause !SU_clause !FAhO_clause expr:any_word_SA_handling { expr }

BRIVLA_clause <object> = pre:BRIVLA_pre post:BRIVLA_post { new { label = "BRIVLA_clause", pre, post } } / arg:zei_clause { new { label = "BRIVLA_clause", arg } }
BRIVLA_pre <object> = pre:pre_clause arg:BRIVLA post:spaces? { new { label = "BRIVLA_pre", pre, arg, post } }
BRIVLA_post = post_clause

CMENE_clause <object> = pre:CMENE_pre post:CMENE_post { new { label = "CMENE_clause", pre, post } }
CMENE_pre <object> = pre:pre_clause arg:CMENE post:spaces? { new { label = "CMENE_pre", pre, arg, post } }
CMENE_post = post_clause

CMAVO_clause <object> = pre:CMAVO_pre post:CMAVO_post { new { label = "CMAVO_clause", pre, post } }
CMAVO_pre <object> = pre:pre_clause arg:CMAVO post:spaces? { new { label = "CMAVO_pre", pre, arg, post } }
CMAVO_post = post_clause

//         eks; basic afterthought logical connectives 
A_clause <object> = pre:A_pre post:A_post { new { label = "A_clause", pre, post } }
A_pre <object> = pre:pre_clause arg:A post:spaces? { new { label = "A_pre", pre, arg, post } }
A_post = post_clause

//         modal operators 
BAI_clause <object> = pre:BAI_pre post:BAI_post { new { label = "BAI_clause", pre, post } }
BAI_pre <object> = pre:pre_clause arg:BAI post:spaces? { new { label = "BAI_pre", pre, arg, post } }
BAI_post = post_clause

//         next word intensifier 
BAhE_clause <object> = arg:(<object> pre:BAhE_pre post:BAhE_post { new { pre, post } })+ { new { label = "BAhE_clause", arg } }
BAhE_pre <object> = arg:BAhE post:spaces? { new { label = "BAhE_pre", arg, post } }
BAhE_post <object> = expr:si_clause? !ZEI_clause !BU_clause { expr.SingleOrDefault() }

//         sumti link to attach sumti to a selbri 
BE_clause <object> = pre:BE_pre post:BE_post  { new { label = "BE_clause", pre, post } }
BE_pre <object> = pre:pre_clause arg:BE post:spaces? { new { label = "BE_pre", pre, arg, post } }
BE_post = post_clause

//         multiple sumti separator between BE, BEI 
BEI_clause <object> = pre:BEI_pre post:BEI_post { new { label = "BEI_clause", pre, post } }
BEI_pre <object> = pre:pre_clause arg:BEI post:spaces? { new { label = "BEI_pre", pre, arg, post } }
BEI_post = post_clause

//         terminates BEBEI specified descriptors 
BEhO_clause <object> = pre:BEhO_pre post:BEhO_post { new { label = "BEhO_clause", pre, post } }
BEhO_pre <object> = pre:pre_clause arg:BEhO post:spaces? { new { label = "BEhO_pre", pre, arg, post } }
BEhO_post = post_clause

//         prefix for high_priority MEX operator
BIhE_clause <object> = pre:BIhE_pre post:BIhE_post  { new { label = "BIhE_clause", pre, post } }
BIhE_pre <object> = pre:pre_clause arg:BIhE post:spaces? { new { label = "BIhE_pre", pre, arg, post } }
BIhE_post = post_clause

//         interval component of JOI 
BIhI_clause <object> = pre:BIhI_pre post:BIhI_post { new { label = "BIhI_clause", pre, post } }
BIhI_pre <object> = pre:pre_clause arg:BIhI post:spaces? { new { label = "BIhI_pre", pre, arg, post } }
BIhI_post = post_clause

//         joins two units with shortest scope 
BO_clause <object> = pre:BO_pre post:BO_post  { new { label = "BO_clause", pre, post } }
BO_pre <object> = pre:pre_clause arg:BO post:spaces? { new { label = "BO_pre", pre, arg, post } }
BO_post = post_clause

//         number or lerfu_string terminator 
BOI_clause <object> = pre:BOI_pre post:BOI_post { new { label = "BOI_clause", pre, post } }
BOI_pre <object> = pre:pre_clause arg:BOI post:spaces? { new { label = "BOI_pre", pre, arg, post } }
BOI_post = post_clause

//         turns any word into a BY lerfu word 
BU_clause <object> = pre:BU_pre post:BU_post { new { label = "BU_clause", pre, post } }
BU_pre <object> = pre:pre_clause arg:BU post:spaces? { new { label = "BU_pre", pre, arg, post } }
BU_post = spaces?

//         individual lerfu words 
BY_clause <object> = pre:BY_pre post:BY_post { new { label = "BY_clause", pre, post } } / expr:bu_clause { new { label = "BY_clause", expr } }
BY_pre <object> = pre:pre_clause arg:BY post:spaces? { new { label = "BY_pre", pre, arg, post } }
BY_post = post_clause

//         specifies actualitypotentiality of tense 
CAhA_clause <object> = pre:CAhA_pre post:CAhA_post { new { label = "CAhA_clause", pre, post } }
CAhA_pre <object> = pre:pre_clause arg:CAhA post:spaces? { new { label = "CAhA_pre", pre, arg, post } }
CAhA_post = post_clause

//         afterthought intensity marker 
CAI_clause <object> = pre:CAI_pre post:CAI_post { new { label = "CAI_clause", pre, post } }
CAI_pre <object> = pre:pre_clause arg:CAI post:spaces? { new { label = "CAI_pre", pre, arg, post } }
CAI_post = post_clause

//         pro_bridi assignment operator 
CEI_clause <object> = pre:CEI_pre post:CEI_post { new { label = "CEI_clause", pre, post } }
CEI_pre <object> = pre:pre_clause arg:CEI post:spaces? { new { label = "CEI_pre", pre, arg, post } }
CEI_post = post_clause

//         afterthought term list connective 
CEhE_clause <object> = pre:CEhE_pre post:CEhE_post { new { label = "CEhE_clause", pre, post } }
CEhE_pre <object> = pre:pre_clause arg:CEhE post:spaces? { new { label = "CEhE_pre", pre, arg, post } }
CEhE_post = post_clause

//         names; require consonant end, then pause no
//                                    LA or DOI selma'o embedded, pause before if
//                                    vowel initial and preceded by a vowel 

//         tanru inversion  
CO_clause <object> = pre:CO_pre post:CO_post { new { label = "CO_clause", pre, post } }
CO_pre <object> = pre:pre_clause arg:CO post:spaces? { new { label = "CO_pre", pre, arg, post } }
CO_post = post_clause

COI_clause <object> = pre:COI_pre post:COI_post { new { label = "COI_clause", pre, post } }
COI_pre <object> = pre:pre_clause arg:COI post:spaces? { new { label = "COI_pre", pre, arg, post } }
COI_post = post_clause

//         vocative marker permitted inside names; must

//                                    always be followed by pause or DOI 

//         separator between head sumti and selbri 
CU_clause <object> = pre:CU_pre post:CU_post { new { label = "CU_clause", pre, post } }
CU_pre <object> = pre:pre_clause arg:CU post:spaces? { new { label = "CU_pre", pre, arg, post } }
CU_post = post_clause

//         tensemodal question 
CUhE_clause <object> = pre:CUhE_pre post:CUhE_post { new { label = "CUhE_clause", pre, post } }
CUhE_pre <object> = pre:pre_clause arg:CUhE post:spaces? { new { label = "CUhE_pre", pre, arg, post } }
CUhE_post = post_clause


//         cancel anaphoracataphora assignments 
DAhO_clause <object> = pre:DAhO_pre post:DAhO_post { new { label = "DAhO_clause", pre, post } }
DAhO_pre <object> = pre:pre_clause arg:DAhO post:spaces? { new { label = "DAhO_pre", pre, arg, post } }
DAhO_post = post_clause

//         vocative marker
DOI_clause <object> = pre:DOI_pre post:DOI_post { new { label = "DOI_clause", pre, post } }
DOI_pre <object> = pre:pre_clause arg:DOI post:spaces? { new { label = "DOI_pre", pre, arg, post } }
DOI_post = post_clause

//         terminator for DOI_marked vocatives 
DOhU_clause <object> = pre:DOhU_pre post:DOhU_post { new { label = "DOhU_clause", pre, post } }
DOhU_pre <object> = pre:pre_clause arg:DOhU post:spaces? { new { label = "DOhU_pre", pre, arg, post } }
DOhU_post = post_clause

//         modifier head generic case tag 
FA_clause <object> = pre:FA_pre post:FA_post { new { label = "FA_clause", pre, post } }
FA_pre <object> = pre:pre_clause arg:FA post:spaces? { new { label = "FA_pre", pre, arg, post } }
FA_post = post_clause

//         superdirections in space 
FAhA_clause <object> = pre:FAhA_pre post:FAhA_post { new { label = "FAhA_clause", pre, post } }
FAhA_pre <object> = pre:pre_clause arg:FAhA post:spaces? { new { label = "FAhA_pre", pre, arg, post } }
FAhA_post = post_clause

//         normally elided 'done pause' to indicate end
//                                    of utterance string 

FAhO_clause <object> = pre:pre_clause arg:FAhO post:spaces? { new { label = "FAhO_clause", pre, arg, post } }

//         space interval mod flag 
FEhE_clause <object> = pre:FEhE_pre post:FEhE_post { new { label = "FEhE_clause", pre, post } }
FEhE_pre <object> = pre:pre_clause arg:FEhE post:spaces? { new { label = "FEhE_pre", pre, arg, post } }
FEhE_post = post_clause

//         ends bridi to modal conversion 
FEhU_clause <object> = pre:FEhU_pre post:FEhU_post { new { label = "FEhU_clause", pre, post } }
FEhU_pre <object> = pre:pre_clause arg:FEhU post:spaces? { new { label = "FEhU_pre", pre, arg, post } }
FEhU_post = post_clause

//         marks bridi to modal conversion 
FIhO_clause <object> = pre:FIhO_pre post:FIhO_post { new { label = "FIhO_clause", pre, post } }
FIhO_pre <object> = pre:pre_clause arg:FIhO post:spaces? { new { label = "FIhO_pre", pre, arg, post } }
FIhO_post = post_clause

//         end compound lerfu 
FOI_clause <object> = pre:FOI_pre post:FOI_post { new { label = "FOI_clause", pre, post } }
FOI_pre <object> = pre:pre_clause arg:FOI post:spaces? { new { label = "FOI_pre", pre, arg, post } }
FOI_post = post_clause

//         reverse Polish flag 
FUhA_clause <object> = pre:FUhA_pre post:FUhA_post { new { label = "FUhA_clause", pre, post } }
FUhA_pre <object> = pre:pre_clause arg:FUhA post:spaces? { new { label = "FUhA_pre", pre, arg, post } }
FUhA_post = post_clause
// FUhA_no_SA_handling <object> = pre:pre_clause arg:FUhA post:post_clause { new { label = "FUhA_no_SA_handling", pre, arg, post } }

//         open long scope for indicator 
FUhE_clause <object> = pre:FUhE_pre post:FUhE_post { new { label = "FUhE_clause", pre, post } }
FUhE_pre <object> = pre:pre_clause arg:FUhE post:spaces? { new { label = "FUhE_pre", pre, arg, post } }
FUhE_post <IList<string>> = !BU_clause expr:spaces? !ZEI_clause !BU_clause { expr }
// FUhE_no_SA_handling <object> = pre:pre_clause arg:FUhE post:post_clause { new { label = "FUhE_no_SA_handling", pre, arg, post } }

//         close long scope for indicator 
FUhO_clause <object> = pre:FUhO_pre post:FUhO_post { new { label = "FUhO_clause", pre, post } }
FUhO_pre <object> = pre:pre_clause arg:FUhO post:spaces? { new { label = "FUhO_pre", pre, arg, post } }
FUhO_post = post_clause
// FUhO_no_SA_handling <object> = pre:pre_clause arg:FUhO post:post_clause { new { label = "FUhO_no_SA_handling", pre, arg, post } }


//         geks; forethought logical connectives 
GA_clause <object> = pre:GA_pre post:GA_post { new { label = "GA_clause", pre, post } }
GA_pre <object> = pre:pre_clause arg:GA post:spaces? { new { label = "GA_pre", pre, arg, post } }
GA_post = post_clause
// GA_no_SA_handling <object> = pre:pre_clause arg:GA post:post_clause { new { label = "GA_no_SA_handling", pre, arg, post } }

//         openclosed interval markers for BIhI 
GAhO_clause <object> = pre:GAhO_pre post:GAhO_post { new { label = "GAhO_clause", pre, post } }
GAhO_pre <object> = pre:pre_clause arg:GAhO post:spaces? { new { label = "GAhO_pre", pre, arg, post } }
GAhO_post = post_clause
// GAhO_no_SA_handling <object> = pre:pre_clause arg:GAhO post:post_clause { new { label = "GAhO_no_SA_handling", pre, arg, post } }

//         marker ending GOI relative clauses 
GEhU_clause <object> = pre:GEhU_pre post:GEhU_post { new { label = "GEhU_clause", pre, post } }
GEhU_pre <object> = pre:pre_clause arg:GEhU post:spaces? { new { label = "GEhU_pre", pre, arg, post } }
GEhU_post = post_clause
// GEhU_no_SA_handling <object> = pre:pre_clause arg:GEhU post:post_clause { new { label = "GEhU_no_SA_handling", pre, arg, post } }

//         forethought medial marker 
GI_clause <object> = pre:GI_pre post:GI_post { new { label = "GI_clause", pre, post } }
GI_pre <object> = pre:pre_clause arg:GI post:spaces? { new { label = "GI_pre", pre, arg, post } }
GI_post = post_clause
// GI_no_SA_handling <object> = pre:pre_clause arg:GI post:post_clause { new { label = "GI_no_SA_handling", pre, arg, post } }

//         logical connectives for bridi_tails 
GIhA_clause <object> = pre:GIhA_pre post:GIhA_post { new { label = "GIhA_clause", pre, post } }
GIhA_pre <object> = pre:pre_clause arg:GIhA post:spaces? { new { label = "GIhA_pre", pre, arg, post } }
GIhA_post = post_clause
// GIhA_no_SA_handling <object> = pre:pre_clause arg:GIhA post:post_clause { new { label = "GIhA_no_SA_handling", pre, arg, post } }

//         attaches a sumti modifier to a sumti 
GOI_clause <object> = pre:GOI_pre post:GOI_post { new { label = "GOI_clause", pre, post } }
GOI_pre <object> = pre:pre_clause arg:GOI post:spaces? { new { label = "GOI_pre", pre, arg, post } }
GOI_post = post_clause
// GOI_no_SA_handling <object> = pre:pre_clause arg:GOI post:post_clause { new { label = "GOI_no_SA_handling", pre, arg, post } }

//         pro_bridi 
GOhA_clause <object> = pre:GOhA_pre post:GOhA_post { new { label = "GOhA_clause", pre, post } }
GOhA_pre <object> = pre:pre_clause arg:GOhA post:spaces? { new { label = "GOhA_pre", pre, arg, post } }
GOhA_post = post_clause
// GOhA_no_SA_handling <object> = pre:pre_clause arg:GOhA post:post_clause { new { label = "GOhA_no_SA_handling", pre, arg, post } }

//         GEK for tanru units, corresponds to JEKs 
GUhA_clause <object> = pre:GUhA_pre post:GUhA_post { new { label = "GUhA_clause", pre, post } }
GUhA_pre <object> = pre:pre_clause arg:GUhA post:spaces? { new { label = "GUhA_pre", pre, arg, post } }
GUhA_post = post_clause
// GUhA_no_SA_handling <object> = pre:pre_clause arg:GUhA post:post_clause { new { label = "GUhA_no_SA_handling", pre, arg, post } }


//         sentence link 
I_clause <object> = expr:(sentence_sa* I_pre I_post) { new { label = "I_clause", arg = expr } }
I_pre <object> = pre:pre_clause arg:I post:spaces? { new { label = "I_pre", pre, arg, post } }
I_post = post_clause
// I_no_SA_handling <object> = pre:pre_clause arg:I post:post_clause { new { label = "I_no_SA_handling", pre, arg, post } }


//         jeks; logical connectives within tanru 
JA_clause <object> = pre:JA_pre post:JA_post { new { label = "JA_clause", pre, post } }
JA_pre <object> = pre:pre_clause arg:JA post:spaces? { new { label = "JA_pre", pre, arg, post } }
JA_post = post_clause
// JA_no_SA_handling <object> = pre:pre_clause arg:JA post:post_clause { new { label = "JA_no_SA_handling", pre, arg, post } }

//         modal conversion flag 
JAI_clause <object> = pre:JAI_pre post:JAI_post { new { label = "JAI_clause", pre, post } }
JAI_pre <object> = pre:pre_clause arg:JAI post:spaces? { new { label = "JAI_pre", pre, arg, post } }
JAI_post = post_clause
// JAI_no_SA_handling <object> = pre:pre_clause arg:JAI post:post_clause { new { label = "JAI_no_SA_handling", pre, arg, post } }

//         flags an array operand 
JOhI_clause <object> = pre:JOhI_pre post:JOhI_post { new { label = "JOhI_clause", pre, post } }
JOhI_pre <object> = pre:pre_clause arg:JOhI post:spaces? { new { label = "JOhI_pre", pre, arg, post } }
JOhI_post = post_clause
// JOhI_no_SA_handling <object> = pre:pre_clause arg:JOhI post:post_clause { new { label = "JOhI_no_SA_handling", pre, arg, post } }

//         non_logical connectives 
JOI_clause <object> = pre:JOI_pre post:JOI_post { new { label = "JOI_clause", pre, post } }
JOI_pre <object> = pre:pre_clause arg:JOI post:spaces? { new { label = "JOI_pre", pre, arg, post } }
JOI_post = post_clause
// JOI_no_SA_handling <object> = pre:pre_clause arg:JOI post:post_clause { new { label = "JOI_no_SA_handling", pre, arg, post } }


//         left long scope marker 
KE_clause <object> = pre:KE_pre post:KE_post { new { label = "KE_clause", pre, post } }
KE_pre <object> = pre:pre_clause arg:KE post:spaces? { new { label = "KE_pre", pre, arg, post } }
KE_post = post_clause
// KE_no_SA_handling <object> = pre:pre_clause arg:KE post:post_clause { new { label = "KE_no_SA_handling", pre, arg, post } }

//         right terminator for KE groups 
KEhE_clause <object> = pre:KEhE_pre post:KEhE_post { new { label = "KEhE_clause", pre, post } }
KEhE_pre <object> = pre:pre_clause arg:KEhE post:spaces? { new { label = "KEhE_pre", pre, arg, post } }
KEhE_post = post_clause
// KEhE_no_SA_handling <object> = pre:pre_clause arg:KEhE post:post_clause { new { label = "KEhE_no_SA_handling", pre, arg, post } }

//         right terminator, NU abstractions 
KEI_clause <object> = pre:KEI_pre post:KEI_post { new { label = "KEI_clause", pre, post } }
KEI_pre <object> = pre:pre_clause arg:KEI post:spaces? { new { label = "KEI_pre", pre, arg, post } }
KEI_post = post_clause
KEI_no_SA_handling <object> = pre:pre_clause arg:KEI post:post_clause { new { label = "KEI_no_SA_handling", pre, arg, post } }

//         multiple utterance scope for tenses 
KI_clause <object> = pre:KI_pre post:KI_post { new { label = "KI_clause", pre, post } }
KI_pre <object> = pre:pre_clause arg:KI post:spaces? { new { label = "KI_pre", pre, arg, post } }
KI_post = post_clause
// KI_no_SA_handling <object> = pre:pre_clause arg:KI post:post_clause { new { label = "KI_no_SA_handling", pre, arg, post } }

//         sumti anaphora 
KOhA_clause <object> = pre:KOhA_pre post:KOhA_post { new { label = "KOhA_clause", pre, post } }
KOhA_pre <object> = pre:pre_clause arg:KOhA post:spaces? { new { label = "KOhA_pre", pre, arg, post } }
KOhA_post = post_clause
// KOhA_no_SA_handling <object> = pre:pre_clause arg:KOhA post:spaces? { new { label = "KOhA_no_SA_handling", pre, arg, post } }

//         right terminator for descriptions, etc. 
KU_clause <object> = pre:KU_pre post:KU_post { new { label = "KU_clause", pre, post } }
KU_pre <object> = pre:pre_clause arg:KU post:spaces? { new { label = "KU_pre", pre, arg, post } }
KU_post = post_clause
// KU_no_SA_handling <object> = pre:pre_clause arg:KU post:post_clause { new { label = "KU_no_SA_handling", pre, arg, post } }

//         MEX forethought delimiter 
KUhE_clause <object> = pre:KUhE_pre post:KUhE_post { new { label = "KUhE_clause", pre, post } }
KUhE_pre <object> = pre:pre_clause arg:KUhE post:spaces? { new { label = "KUhE_pre", pre, arg, post } }
KUhE_post = post_clause
// KUhE_no_SA_handling <object> = pre:pre_clause arg:KUhE post:post_clause { new { label = "KUhE_no_SA_handling", pre, arg, post } }

//         right terminator, NOI relative clauses 
KUhO_clause <object> = pre:KUhO_pre post:KUhO_post { new { label = "KUhO_clause", pre, post } }
KUhO_pre <object> = pre:pre_clause arg:KUhO post:spaces? { new { label = "KUhO_pre", pre, arg, post } }
KUhO_post = post_clause
// KUhO_no_SA_handling <object> = pre:pre_clause arg:KUhO post:post_clause { new { label = "KUhO_no_SA_handling", pre, arg, post } }


//         name descriptors 
LA_clause <object> = pre:LA_pre post:LA_post { new { label = "LA_clause", pre, post } }
LA_pre <object> = pre:pre_clause arg:LA post:spaces? { new { label = "LA_pre", pre, arg, post } }
LA_post = post_clause
// LA_no_SA_handling <object> = pre:pre_clause arg:LA post:post_clause { new { label = "LA_no_SA_handling", pre, arg, post } }

//         lerfu prefixes 
LAU_clause <object> = pre:LAU_pre post:LAU_post { new { label = "LAU_clause", pre, post } }
LAU_pre <object> = pre:pre_clause arg:LAU post:spaces? { new { label = "LAU_pre", pre, arg, post } }
LAU_post = post_clause
// LAU_no_SA_handling <object> = pre:pre_clause arg:LAU post:post_clause { new { label = "LAU_no_SA_handling", pre, arg, post } }

//         sumti qualifiers 
LAhE_clause <object> = pre:LAhE_pre post:LAhE_post { new { label = "LAhE_clause", pre, post } }
LAhE_pre <object> = pre:pre_clause arg:LAhE post:spaces? { new { label = "LAhE_pre", pre, arg, post } }
LAhE_post = post_clause
// LAhE_no_SA_handling <object> = pre:pre_clause arg:LAhE post:post_clause { new { label = "LAhE_no_SA_handling", pre, arg, post } }

//         sumti descriptors 
LE_clause <object> = pre:LE_pre post:LE_post { new { label = "LE_clause", pre, post } }
LE_pre <object> = pre:pre_clause arg:LE post:spaces? { new { label = "LE_pre", pre, arg, post } }
LE_post = post_clause
// LE_no_SA_handling <object> = pre:pre_clause arg:LE post:post_clause { new { label = "LE_no_SA_handling", pre, arg, post } }


//         possibly ungrammatical text right quote 
LEhU_clause <object> = pre:LEhU_pre post:LEhU_post { new { label = "LEhU_clause", pre, post } }
LEhU_pre <object> = pre:pre_clause arg:LEhU post:spaces? { new { label = "LEhU_pre", pre, arg, post } }
LEhU_post = spaces?
// LEhU_clause_no_SA = LEhU_pre_no_SA LEhU_post
// LEhU_pre_no_SA = pre_clause LEhU spaces?
// LEhU_no_SA_handling <object> = pre:pre_clause arg:LEhU post:post_clause { new { label = "LEhU_no_SA_handling", pre, arg, post } }

//         convert number to sumti 
LI_clause <object> = pre:LI_pre post:LI_post { new { label = "LI_clause", pre, post } }
LI_pre <object> = pre:pre_clause arg:LI post:spaces? { new { label = "LI_pre", pre, arg, post } }
LI_post = post_clause
// LI_no_SA_handling <object> = pre:pre_clause arg:LI post:post_clause { new { label = "LI_no_SA_handling", pre, arg, post } }

//         grammatical text right quote 
LIhU_clause <object> = pre:LIhU_pre post:LIhU_post { new { label = "LIhU_clause", pre, post } }
LIhU_pre <object> = pre:pre_clause arg:LIhU post:spaces? { new { label = "LIhU_pre", pre, arg, post } }
LIhU_post = post_clause
// LIhU_no_SA_handling <object> = pre:pre_clause arg:LIhU post:post_clause { new { label = "LIhU_no_SA_handling", pre, arg, post } }

//         elidable terminator for LI 
LOhO_clause <object> = pre:LOhO_pre post:LOhO_post { new { label = "LOhO_clause", pre, post } }
LOhO_pre <object> = pre:pre_clause arg:LOhO post:spaces? { new { label = "LOhO_pre", pre, arg, post } }
LOhO_post = post_clause
// LOhO_no_SA_handling <object> = pre:pre_clause arg:LOhO post:post_clause { new { label = "LOhO_no_SA_handling", pre, arg, post } }

//         possibly ungrammatical text left quote 
LOhU_clause <object> = pre:LOhU_pre post:LOhU_post { new { label = "LOhU_clause", pre, post } }
LOhU_pre <object> = pre:pre_clause arg:LOhU post:spaces? words:(<object> !LEhU word:any_word { word })* close:LEhU_clause after:spaces? { new { label = "LOhU_pre", pre, arg, post, value = new { words, close, after } } }
LOhU_post = post_clause
// LOhU_no_SA_handling <object> = pre:pre_clause arg:LOhU post:spaces? words:(<object> !LEhU word:any_word { word })* close:LEhU_clause after:spaces? { new { label = "LOhU_no_SA_handling", pre, arg, post, value = new { words, close, after } } }

//         grammatical text left quote 
LU_clause <object> = pre:LU_pre post:LU_post { new { label = "LU_clause", pre, post } }
LU_pre <object> = pre:pre_clause arg:LU post:spaces? { new { label = "LU_pre", pre, arg, post } }
LU_post = post_clause
// LU_no_SA_handling <object> = pre:pre_clause arg:LU post:post_clause { new { label = "LU_no_SA_handling", pre, arg, post } }

//         LAhE close delimiter 
LUhU_clause <object> = pre:LUhU_pre post:LUhU_post { new { label = "LUhU_clause", pre, post } }
LUhU_pre <object> = pre:pre_clause arg:LUhU post:spaces? { new { label = "LUhU_pre", pre, arg, post } }
LUhU_post = post_clause
// LUhU_no_SA_handling <object> = pre:pre_clause arg:LUhU post:post_clause { new { label = "LUhU_no_SA_handling", pre, arg, post } }


//         change MEX expressions to MEX operators 
MAhO_clause <object> = pre:MAhO_pre post:MAhO_post { new { label = "MAhO_clause", pre, post } }
MAhO_pre <object> = pre:pre_clause arg:MAhO post:spaces? { new { label = "MAhO_pre", pre, arg, post } }
MAhO_post = post_clause
// MAhO_no_SA_handling <object> = pre:pre_clause arg:MAhO post:post_clause { new { label = "MAhO_no_SA_handling", pre, arg, post } }

//         change numbers to utterance ordinals 
MAI_clause <object> = pre:MAI_pre post:MAI_post { new { label = "MAI_clause", pre, post } }
MAI_pre <object> = pre:pre_clause arg:MAI post:spaces? { new { label = "MAI_pre", pre, arg, post } }
MAI_post = post_clause
// MAI_no_SA_handling <object> = pre:pre_clause arg:MAI post:post_clause { new { label = "MAI_no_SA_handling", pre, arg, post } }

//         converts a sumti into a tanru_unit 
ME_clause <object> = pre:ME_pre post:ME_post { new { label = "ME_clause", pre, post } }
ME_pre <object> = pre:pre_clause arg:ME post:spaces? { new { label = "ME_pre", pre, arg, post } }
ME_post = post_clause
// ME_no_SA_handling <object> = pre:pre_clause arg:ME post:post_clause { new { label = "ME_no_SA_handling", pre, arg, post } }

//         terminator for ME 
MEhU_clause <object> = pre:MEhU_pre post:MEhU_post { new { label = "MEhU_clause", pre, post } }
MEhU_pre <object> = pre:pre_clause arg:MEhU post:spaces? { new { label = "MEhU_pre", pre, arg, post } }
MEhU_post = post_clause
// MEhU_no_SA_handling <object> = pre:pre_clause arg:MEhU post:post_clause { new { label = "MEhU_no_SA_handling", pre, arg, post } }

//         change sumti to operand, inverse of LI 
MOhE_clause <object> = pre:MOhE_pre post:MOhE_post { new { label = "MOhE_clause", pre, post } }
MOhE_pre <object> = pre:pre_clause arg:MOhE post:spaces? { new { label = "MOhE_pre", pre, arg, post } }
MOhE_post = post_clause
// MOhE_no_SA_handling <object> = pre:pre_clause arg:MOhE post:post_clause { new { label = "MOhE_no_SA_handling", pre, arg, post } }

//         motion tense marker 
MOhI_clause <object> = pre:MOhI_pre post:MOhI_post { new { label = "MOhI_clause", pre, post } }
MOhI_pre <object> = pre:pre_clause arg:MOhI post:spaces? { new { label = "MOhI_pre", pre, arg, post } }
MOhI_post = post_clause
// MOhI_no_SA_handling <object> = pre:pre_clause arg:MOhI post:post_clause { new { label = "MOhI_no_SA_handling", pre, arg, post } }

//         change number to selbri 
MOI_clause <object> = pre:MOI_pre post:MOI_post { new { label = "MOI_clause", pre, post } }
MOI_pre <object> = pre:pre_clause arg:MOI post:spaces? { new { label = "MOI_pre", pre, arg, post } }
MOI_post = post_clause
// MOI_no_SA_handling <object> = pre:pre_clause arg:MOI post:post_clause { new { label = "MOI_no_SA_handling", pre, arg, post } }


//         bridi negation  
NA_clause <object> = pre:NA_pre post:NA_post { new { label = "NA_clause", pre, post } }
NA_pre <object> = pre:pre_clause arg:NA post:spaces? { new { label = "NA_pre", pre, arg, post } }
NA_post = post_clause
// NA_no_SA_handling <object> = pre:pre_clause arg:NA post:post_clause { new { label = "NA_no_SA_handling", pre, arg, post } }

//         attached to words to negate them 
NAI_clause <object> = pre:NAI_pre post:NAI_post { new { label = "NAI_clause", pre, post } }
NAI_pre <object> = pre:pre_clause arg:NAI post:spaces? { new { label = "NAI_pre", pre, arg, post } }
NAI_post = post_clause
// NAI_no_SA_handling <object> = pre:pre_clause arg:NAI post:post_clause { new { label = "NAI_no_SA_handling", pre, arg, post } }

//         scalar negation  
NAhE_clause <object> = pre:NAhE_pre post:NAhE_post { new { label = "NAhE_clause", pre, post } }
NAhE_pre <object> = pre:pre_clause arg:NAhE post:spaces? { new { label = "NAhE_pre", pre, arg, post } }
NAhE_post = post_clause
// NAhE_no_SA_handling <object> = pre:pre_clause arg:NAhE post:post_clause { new { label = "NAhE_no_SA_handling", pre, arg, post } }

//         change a selbri into an operator 
NAhU_clause <object> = pre:NAhU_pre post:NAhU_post { new { label = "NAhU_clause", pre, post } }
NAhU_pre <object> = pre:pre_clause arg:NAhU post:spaces? { new { label = "NAhU_pre", pre, arg, post } }
NAhU_post = post_clause
// NAhU_no_SA_handling <object> = pre:pre_clause arg:NAhU post:post_clause { new { label = "NAhU_no_SA_handling", pre, arg, post } }

//         change selbri to operand; inverse of MOI 
NIhE_clause <object> = pre:NIhE_pre post:NIhE_post { new { label = "NIhE_clause", pre, post } }
NIhE_pre <object> = pre:pre_clause arg:NIhE post:spaces? { new { label = "NIhE_pre", pre, arg, post } }
NIhE_post = post_clause
// NIhE_no_SA_handling <object> = pre:pre_clause arg:NIhE post:post_clause { new { label = "NIhE_no_SA_handling", pre, arg, post } }

//         new paragraph; change of subject 
NIhO_clause <object> = expr:(sentence_sa* NIhO_pre NIhO_post) { new { label = "NIhO_clause", arg = expr } }
NIhO_pre <object> = pre:pre_clause arg:NIhO post:spaces? { new { label = "NIhO_pre", pre, arg, post } }
NIhO_post = su_clause* post_clause
// NIhO_no_SA_handling = pre_clause NIhO su_clause* post_clause

//         attaches a subordinate clause to a sumti 
NOI_clause <object> = pre:NOI_pre post:NOI_post { new { label = "NOI_clause", pre, post } }
NOI_pre <object> = pre:pre_clause arg:NOI post:spaces? { new { label = "NOI_pre", pre, arg, post } }
NOI_post = post_clause
// NOI_no_SA_handling <object> = pre:pre_clause arg:NOI post:post_clause { new { label = "NOI_no_SA_handling", pre, arg, post } }

//         abstraction  
NU_clause <object> = pre:NU_pre post:NU_post { new { label = "NU_clause", pre, post } }
NU_pre <object> = pre:pre_clause arg:NU post:spaces? { new { label = "NU_pre", pre, arg, post } }
NU_post = post_clause
// NU_no_SA_handling <object> = pre:pre_clause arg:NU post:post_clause { new { label = "NU_no_SA_handling", pre, arg, post } }

//         change operator to selbri; inverse of MOhE 
NUhA_clause <object> = pre:NUhA_pre post:NUhA_post { new { label = "NUhA_clause", pre, post } }
NUhA_pre <object> = pre:pre_clause arg:NUhA post:spaces? { new { label = "NUhA_pre", pre, arg, post } }
NUhA_post = post_clause
// NUhA_no_SA_handling <object> = pre:pre_clause arg:NUhA post:post_clause { new { label = "NUhA_no_SA_handling", pre, arg, post } }

//         marks the start of a termset 
NUhI_clause <object> = pre:NUhI_pre post:NUhI_post { new { label = "NUhI_clause", pre, post } }
NUhI_pre <object> = pre:pre_clause arg:NUhI post:spaces? { new { label = "NUhI_pre", pre, arg, post } }
NUhI_post = post_clause
// NUhI_no_SA_handling <object> = pre:pre_clause arg:NUhI post:post_clause { new { label = "NUhI_no_SA_handling", pre, arg, post } }

//         marks the middle and end of a termset 
NUhU_clause <object> = pre:NUhU_pre post:NUhU_post { new { label = "NUhU_clause", pre, post } }
NUhU_pre <object> = pre:pre_clause arg:NUhU post:spaces? { new { label = "NUhU_pre", pre, arg, post } }
NUhU_post = post_clause
// NUhU_no_SA_handling <object> = pre:pre_clause arg:NUhU post:post_clause { new { label = "NUhU_no_SA_handling", pre, arg, post } }


//         numbers and numeric punctuation 
PA_clause <object> -memoize = pre:PA_pre post:PA_post { new { label = "PA_clause", pre, post } }
PA_pre <object> = pre:pre_clause arg:PA post:spaces? { new { label = "PA_pre", pre, arg, post } }
PA_post = post_clause
// PA_no_SA_handling <object> = pre:pre_clause arg:PA post:post_clause { new { label = "PA_no_SA_handling", pre, arg, post } }

//         afterthought termset connective prefix 
PEhE_clause <object> = pre:PEhE_pre post:PEhE_post { new { label = "PEhE_clause", pre, post } }
PEhE_pre <object> = pre:pre_clause arg:PEhE post:spaces? { new { label = "PEhE_pre", pre, arg, post } }
PEhE_post = post_clause
// PEhE_no_SA_handling <object> = pre:pre_clause arg:PEhE post:post_clause { new { label = "PEhE_no_SA_handling", pre, arg, post } }

//         forethought (Polish) flag 
PEhO_clause <object> = pre:PEhO_pre post:PEhO_post { new { label = "PEhO_clause", pre, post } }
PEhO_pre <object> = pre:pre_clause arg:PEhO post:spaces? { new { label = "PEhO_pre", pre, arg, post } }
PEhO_post = post_clause
// PEhO_no_SA_handling <object> = pre:pre_clause arg:PEhO post:post_clause { new { label = "PEhO_no_SA_handling", pre, arg, post } }

//         directions in time 
PU_clause <object> = pre:PU_pre post:PU_post { new { label = "PA_clause", pre, post } }
PU_pre <object> = pre:pre_clause arg:PU post:spaces? { new { label = "PU_pre", pre, arg, post } }
PU_post = post_clause
// PU_no_SA_handling <object> = pre:pre_clause arg:PU post:post_clause { new { label = "PU_no_SA_handling", pre, arg, post } }


//         flag for modified interpretation of GOhI 
RAhO_clause <object> = pre:RAhO_pre post:RAhO_post { new { label = "RAhO_clause", pre, post } }
RAhO_pre <object> = pre:pre_clause arg:RAhO post:spaces? { new { label = "RAhO_pre", pre, arg, post } }
RAhO_post = post_clause
// RAhO_no_SA_handling <object> = pre:pre_clause arg:RAhO post:post_clause { new { label = "RAhO_no_SA_handling", pre, arg, post } }

//         converts number to extensional tense 
ROI_clause <object> = pre:ROI_pre post:ROI_post { new { label = "ROI_clause", pre, post } }
ROI_pre <object> = pre:pre_clause arg:ROI post:spaces? { new { label = "ROI_pre", pre, arg, post } }
ROI_post = post_clause
// ROI_no_SA_handling <object> = pre:pre_clause arg:ROI post:post_clause { new { label = "ROI_no_SA_handling", pre, arg, post } }

SA_clause <object> = pre:SA_pre post:SA_post { new { label = "SA_clause", pre, post } }
SA_pre <object> = pre:pre_clause arg:SA post:spaces? { new { label = "SA_pre", pre, arg, post } }
SA_post = spaces?

//         metalinguistic eraser to the beginning of

//                                    the current utterance 

//         conversions 
SE_clause <object> = pre:SE_pre post:SE_post { new { label = "SE_clause", pre, post } }
SE_pre <object> = pre:pre_clause arg:SE post:spaces? { new { label = "SE_pre", pre, arg, post } }
SE_post = post_clause
// SE_no_SA_handling <object> = pre:pre_clause arg:SE post:post_clause { new { label = "SE_no_SA_handling", pre, arg, post } }

//         metalinguistic bridi insert marker 
SEI_clause <object> = pre:SEI_pre post:SEI_post { new { label = "SEI_clause", pre, post } }
SEI_pre <object> = pre:pre_clause arg:SEI post:spaces? { new { label = "SEI_pre", pre, arg, post } }
SEI_post = post_clause
// SEI_no_SA_handling <object> = pre:pre_clause arg:SEI post:post_clause { new { label = "SEI_no_SA_handling", pre, arg, post } }

//         metalinguistic bridi end marker 
SEhU_clause <object> = pre:SEhU_pre post:SEhU_post { new { label = "SEhU_clause", pre, post } }
SEhU_pre <object> = pre:pre_clause arg:SEhU post:spaces? { new { label = "SEhU_pre", pre, arg, post } }
SEhU_post = post_clause
// SEhU_no_SA_handling <object> = pre:pre_clause arg:SEhU post:post_clause { new { label = "SEhU_no_SA_handling", pre, arg, post } }

//         metalinguistic single word eraser 
SI_clause <object> = pre:spaces? arg:SI post:spaces? { new { label = "SI_clause", pre, arg, post } }

//         reciprocal sumti marker 
SOI_clause <object> = pre:SOI_pre post:SOI_post { new { label = "SOI_clause", arg = pre, post } } 
SOI_pre <object> = pre:pre_clause arg:SOI post:spaces? { new { label = "SOI_pre", pre, arg, post } }
SOI_post = post_clause
// SOI_no_SA_handling <object> = pre:pre_clause arg:SOI post:post_clause { new { label = "SOI_no_SA_handling", pre, arg, post } }

//         metalinguistic eraser of the entire text 
SU_clause <object> = pre:SU_pre post:SU_post { new { label = "SU_clause", arg = pre, post } }
SU_pre <object> = pre:pre_clause arg:SU post:spaces? { new { label = "SU_pre", pre, arg, post } }
SU_post = post_clause


//         tense interval properties 
TAhE_clause <object> = pre:TAhE_pre post:TAhE_post { new { label = "TAhE_clause", pre, post } }
TAhE_pre <object> = pre:pre_clause arg:TAhE post:spaces? { new { label = "TAhE_pre", pre, arg, post } }
TAhE_post = post_clause
// TAhE_no_SA_handling <object> = pre:pre_clause arg:TAhE post:post_clause { new { label = "TAhE_no_SA_handling", pre, arg, post } }

//         closing gap for MEX constructs 
TEhU_clause <object> = pre:TEhU_pre post:TEhU_post { new { label = "TEhU_clause", arg = pre, post } }
TEhU_pre <object> = pre:pre_clause arg:TEhU post:spaces? { new { label = "TEhU_pre", pre, arg, post } }
TEhU_post = post_clause
// TEhU_no_SA_handling <object> = pre:pre_clause arg:TEhU post:post_clause { new { label = "TEhU_no_SA_handling", pre, arg, post } }

//         start compound lerfu 
TEI_clause <object> = pre:TEI_pre post:TEI_post { new { label = "TEI_clause", pre, post } }
TEI_pre <object> = pre:pre_clause arg:TEI post:spaces? { new { label = "TEI_pre", pre, arg, post } }
TEI_post = post_clause
// TEI_no_SA_handling <object> = pre:pre_clause arg:TEI post:post_clause { new { label = "TEI_no_SA_handling", pre, arg, post } }

//         left discursive parenthesis 
TO_clause <object> = pre:TO_pre post:TO_post { new { label = "TO_clause", arg = pre, post } }
TO_pre <object> = pre:pre_clause arg:TO post:spaces? { new { label = "TO_pre", pre, arg, post } }
TO_post = post_clause
// TO_no_SA_handling <object> = pre:pre_clause arg:TO post:post_clause { new { label = "TO_no_SA_handling", pre, arg, post } }

//         right discursive parenthesis 
TOI_clause <object> = pre:TOI_pre post:TOI_post { new { label = "TOI_clause", arg = pre, post } }
TOI_pre <object> = pre:pre_clause arg:TOI post:spaces? { new { label = "TOI_pre", pre, arg, post } }
TOI_post = post_clause
// TOI_no_SA_handling <object> = pre:pre_clause arg:TOI post:post_clause { new { label = "TOI_no_SA_handling", pre, arg, post } }

//         multiple utterance scope mark 
TUhE_clause <object> = pre:TUhE_pre post:TUhE_post { new { label = "TUhE_clause", arg = pre, post } }
TUhE_pre <object> = pre:pre_clause arg:TUhE post:spaces? { new { label = "TUhE_pre", pre, arg, post } }
TUhE_post = su_clause* post_clause
// TUhE_no_SA_handling = pre_clause TUhE su_clause* post_clause

//         multiple utterance end scope mark 
TUhU_clause <object> = pre:TUhU_pre post:TUhU_post { new { label = "TUhU_clause", arg = pre, post } }
TUhU_pre <object> = pre:pre_clause arg:TUhU post:spaces? { new { label = "TUhU_pre", pre, arg, post } }
TUhU_post = post_clause
// TUhU_no_SA_handling <object> = pre:pre_clause arg:TUhU post:post_clause { new { label = "TUhU_no_SA_handling", pre, arg, post } }


//         attitudinals, observationals, discursives 
UI_clause <object> = pre:UI_pre post:UI_post { new { label = "UI_clause", pre, post } }
UI_pre <object> = pre:pre_clause arg:UI post:spaces? { new { label = "UI_pre", pre, arg, post } }
UI_post = post_clause
// UI_no_SA_handling <object> = pre:pre_clause arg:UI post:post_clause { new { label = "UI_no_SA_handling", pre, arg, post } }


//         distance in space_time 
VA_clause <object> = pre:VA_pre post:VA_post { new { label = "VA_clause", arg = pre, post } }
VA_pre <object> = pre:pre_clause arg:VA post:spaces? { new { label = "VA_pre", pre, arg, post } }
VA_post = post_clause
// VA_no_SA_handling <object> = pre:pre_clause arg:VA post:post_clause { new { label = "VA_no_SA_handling", pre, arg, post } }

//         end simple bridi or bridi_tail 
VAU_clause <object> = pre:VAU_pre post:VAU_post { new { label = "VAU_clause", arg = pre, post } }
VAU_pre <object> = pre:pre_clause arg:VAU post:spaces? { new { label = "VAU_pre", pre, arg, post } }
VAU_post = post_clause
// VAU_no_SA_handling <object> = pre:pre_clause arg:VAU post:post_clause { new { label = "VAU_no_SA_handling", pre, arg, post } }

//         left MEX bracket 
VEI_clause <object> = pre:VEI_pre post:VEI_post { new { label = "VEI_clause", arg = pre, post } }
VEI_pre <object> = pre:pre_clause arg:VEI post:spaces? { new { label = "VEI_pre", pre, arg, post } }
VEI_post = post_clause
// VEI_no_SA_handling <object> = pre:pre_clause arg:VEI post:post_clause { new { label = "VEI_no_SA_handling", pre, arg, post } }

//         right MEX bracket 
VEhO_clause <object> = pre:VEhO_pre post:VEhO_post { new { label = "VEhO_clause", arg = pre, post } }
VEhO_pre <object> = pre:pre_clause arg:VEhO post:spaces? { new { label = "VEhO_pre", pre, arg, post } }
VEhO_post = post_clause
// VEhO_no_SA_handling <object> = pre:pre_clause arg:VEhO post:post_clause { new { label = "VEhO_no_SA_handling", pre, arg, post } }

//         MEX operator 
VUhU_clause <object> = pre:VUhU_pre post:VUhU_post { new { label = "VUhU_clause", pre, post } }
VUhU_pre <object> = pre:pre_clause arg:VUhU post:spaces? { new { label = "VUhU_pre", pre, arg, post } }
VUhU_post = post_clause
// VUhU_no_SA_handling <object> = pre:pre_clause arg:VUhU post:post_clause { new { label = "VUhU_no_SA_handling", pre, arg, post } }

//         space_time interval size 
VEhA_clause <object> = pre:VEhA_pre post:VEhA_post { new { label = "VEhA_clause", pre, post } }
VEhA_pre <object> = pre:pre_clause arg:VEhA post:spaces? { new { label = "VEhA_pre", pre, arg, post } }
VEhA_post = post_clause
// VEhA_no_SA_handling <object> = pre:pre_clause arg:VEhA post:post_clause { new { label = "VEhA_no_SA_handling", pre, arg, post } }

//         space_time dimensionality marker 
VIhA_clause <object> = pre:VIhA_pre post:VIhA_post { new { label = "VIhA_clause", pre, post } }
VIhA_pre <object> = pre:pre_clause arg:VIhA post:spaces? { new { label = "VIhA_pre", pre, arg, post } }
VIhA_post = post_clause
// VIhA_no_SA_handling <object> = pre:pre_clause arg:VIhA post:post_clause { new { label = "VIhA_no_SA_handling", pre, arg, post } }

VUhO_clause <object> = pre:VUhO_pre post:VUhO_post { new { label = "VUhO_clause", pre, post } }
VUhO_pre <object> = pre:pre_clause arg:VUhO post:spaces? { new { label = "VUhO_pre", pre, arg, post } }
VUhO_post = post_clause
// VUhO_no_SA_handling <object> = pre:pre_clause arg:VUhO post:post_clause { new { label = "VUhO_no_SA_handling", pre, arg, post } }

// glue between logically connected sumti and relative clauses 


//         subscripting operator 
XI_clause <object> = pre:XI_pre post:XI_post { new { label = "XI_clause", pre, post } }
XI_pre <object> = pre:pre_clause arg:XI post:spaces? { new { label = "XI_pre", pre, arg, post } }
XI_post = post_clause
// XI_no_SA_handling <object> = pre:pre_clause arg:XI post:post_clause { new { label = "XI_no_SA_handling", pre, arg, post } }


//         hesitation 
// Very very special case.  Handled in the morphology section.
// Y_clause = spaces? Y spaces?


//         event properties _ inchoative, etc. 
ZAhO_clause <object> = pre:ZAhO_pre post:ZAhO_post { new { label = "ZAhO_clause", pre, post } }
ZAhO_pre <object> = pre:pre_clause arg:ZAhO post:spaces? { new { label = "ZAhO_pre", pre, arg, post } }
ZAhO_post = post_clause
// ZAhO_no_SA_handling <object> = pre:pre_clause arg:ZAhO post:post_clause { new { label = "ZAhO_no_SA_handling", pre, arg, post } }

//         time interval size tense 
ZEhA_clause <object> = pre:ZEhA_pre post:ZEhA_post { new { label = "ZEhA_clause", pre, post } }
ZEhA_pre <object> = pre:pre_clause arg:ZEhA post:spaces? { new { label = "ZEhA_pre", pre, arg, post } }
ZEhA_post = post_clause
// ZEhA_no_SA_handling <object> = pre:pre_clause arg:ZEhA post:post_clause { new { label = "ZEhA_no_SA_handling", pre, arg, post } }

//         lujvo glue 
ZEI_clause <object> = pre:ZEI_pre post:ZEI_post { new { label = "ZEI_clause", pre, post } }
// ZEI_clause_no_SA = ZEI_pre_no_SA ZEI ZEI_post
ZEI_pre <object> = pre:pre_clause arg:ZEI post:spaces? { new { label = "ZEI_pre", pre, arg, post } }
// ZEI_pre_no_SA = pre_clause
ZEI_post = spaces?
// ZEI_no_SA_handling <object> = pre:pre_clause arg:ZEI post:post_clause { new { label = "ZEI_no_SA_handling", pre, arg, post } }

//         time distance tense 
ZI_clause <object> = pre:ZI_pre post:ZI_post { new { label = "ZI_clause", pre, post } }
ZI_pre <object> = pre:pre_clause arg:ZI post:spaces? { new { label = "ZI_pre", pre, arg, post } }
ZI_post = post_clause
// ZI_no_SA_handling <object> = pre:pre_clause arg:ZI post:post_clause { new { label = "ZI_no_SA_handling", pre, arg, post } }

//         conjoins relative clauses 
ZIhE_clause <object> = pre:ZIhE_pre post:ZIhE_post { new { label = "ZIhE_clause", pre, post } }
ZIhE_pre <object> = pre:pre_clause arg:ZIhE post:spaces? { new { label = "ZIhE_pre", pre, arg, post } }
ZIhE_post = post_clause
// ZIhE_no_SA_handling <object> = pre:pre_clause arg:ZIhE post:post_clause { new { label = "ZIhE_no_SA_handling", pre, arg, post } }

//         single word metalinguistic quote marker 
ZO_clause <object> = pre:ZO_pre post:ZO_post { new { label = "ZO_clause", pre, post } }
ZO_pre <object> = pre:pre_clause arg:ZO post:spaces? word:any_word after:spaces? { new { label = "ZO_pre", pre, arg, post, value = new { word, after } } }
ZO_post = post_clause
// ZO_no_SA_handling = pre:pre_clause arg:ZO post:spaces? word:any_word after:spaces? { new { label = "ZO_no_SA_handling", pre, arg, post, value = new { word, after } } }

//         delimited quote marker 
ZOI_clause <object> = pre:ZOI_pre post:ZOI_post { new { label = "ZOI_clause", pre, post } }
ZOI_pre <object> = pre:pre_clause arg:ZOI post:spaces? open:zoi_open words:zoi_word* close:zoi_close after:spaces? { new { label = "ZOI_pre", pre, arg, post, value = new { open, words, close, after } } }
ZOI_post = post_clause
// ZOI_no_SA_handling <object> = pre:pre_clause arg:ZOI post:spaces? open:zoi_open words:zoi_word* close:zoi_close after:spaces? { new { label = "ZOI_no_SA_handling", pre, arg, post, value = new { open, words, close, after } } }

//         prenex terminator (not elidable) 
ZOhU_clause <object> = pre:ZOhU_pre post:ZOhU_post { new { label = "ZOhU_clause", pre, post } }
ZOhU_pre <object> = pre:pre_clause arg:ZOhU post:spaces? { new { label = "ZOhU_pre", pre, arg, post } }
ZOhU_post = post_clause
// ZOhU_no_SA_handling <object> = pre:pre_clause arg:ZOhU post:post_clause { new { label = "ZOhU_no_SA_handling", pre, arg, post } }


// ___ MORPHOLOGY ___

CMENE <object> = expr:cmene { new { label = "CMENE", arg = expr } }
BRIVLA <object> = expr:(gismu_2 / lujvo / fuhivla) { new { label = "BRIVLA", arg = expr } }
gismu_2 <object> = expr:(gismu) { new { label = "gismu", arg = expr } }
CMAVO <object> = expr:(A / BAI / BAhE / BE / BEI / BEhO / BIhE / BIhI / BO / BOI / BU / BY / CAhA / CAI / CEI / CEhE / CO / COI / CU / CUhE / DAhO / DOI / DOhU / FA / FAhA / FAhO / FEhE / FEhU / FIhO / FOI / FUhA / FUhE / FUhO / GA / GAhO / GEhU / GI / GIhA / GOI / GOhA / GUhA / I / JA / JAI / JOhI / JOI / KE / KEhE / KEI / KI / KOhA / KU / KUhE / KUhO / LA / LAU / LAhE / LE / LEhU / LI / LIhU / LOhO / LOhU / LU / LUhU / MAhO / MAI / ME / MEhU / MOhE / MOhI / MOI / NA / NAI / NAhE / NAhU / NIhE / NIhO / NOI / NU / NUhA / NUhI / NUhU / PA / PEhE / PEhO / PU / RAhO / ROI / SA / SE / SEI / SEhU / SI / SOI / SU / TAhE / TEhU / TEI / TO / TOI / TUhE / TUhU / UI / VA / VAU / VEI / VEhO / VUhU / VEhA / VIhA / VUhO / XI / ZAhO / ZEhA / ZEI / ZI / ZIhE / ZO / ZOI / ZOhU / cmavo) { new { label = "CMAVO", arg = expr } }

// This is a Parsing Expression Grammar for the morphology of Lojban.
// ___ GRAMMAR ___
// This grammar classifies words by their morphological class (cmene,
// gismu, lujvo, fuhivla, cmavo, and non_lojban_word).
//
//The final section sorts cmavo into grammatical classes (A, BAI, BAhE, ..., ZOhU).
//
// mi'e ((xorxes))

lojban_word = CMENE / CMAVO / BRIVLA

any_word <object> = arg:lojban_word post:spaces? { new { label = "any_word", arg, post } }

zoi_open = lojban_word
zoi_word = non_lojban_word
zoi_close = lojban_word

//___________________________________________________________________

cmene <object> = expr:(!h &consonant_final coda? (any_syllable / digit)+ &pause) { new { label = "cmene", arg = _join(expr) } }

consonant_final = (non_space &non_space)* consonant &pause

//cmene = !h cmene_syllable* &consonant coda? consonantal_syllable* onset &pause

//cmene_syllable = !doi_la_lai_lahi coda? consonantal_syllable* onset nucleus / digit

//doi_la_lai_lahi = (d o i / l a (h? i)?) !h !nucleus

//___________________________________________________________________

cmavo -memoize = expr:(!cmene !CVCy_lujvo cmavo_form &post_word) { _join(expr) }

CVCy_lujvo = expr:(CVC_rafsi y h? initial_rafsi* brivla_core / stressed_CVC_rafsi y short_final_rafsi) { _join(expr) }

cmavo_form = expr:(!h !cluster onset (nucleus h)* (!stressed nucleus / nucleus !cluster) / "" y+ / digit) { _join(expr) }

//___________________________________________________________________

brivla = expr:(!cmavo initial_rafsi* brivla_core) { _join(expr) }

brivla_core = expr:(fuhivla / gismu / CVV_final_rafsi / stressed_initial_rafsi short_final_rafsi) { _join(expr) }

stressed_initial_rafsi = expr:(stressed_extended_rafsi / stressed_y_rafsi / stressed_y_less_rafsi) { _join(expr) }

initial_rafsi = expr:(extended_rafsi / y_rafsi / !any_extended_rafsi y_less_rafsi) { _join(expr) }

//___________________________________________________________________

any_extended_rafsi = expr:(fuhivla / extended_rafsi / stressed_extended_rafsi) { _join(expr) }

fuhivla = expr:(fuhivla_head stressed_syllable consonantal_syllable* final_syllable) { _join(expr) }

stressed_extended_rafsi = expr:(stressed_brivla_rafsi / stressed_fuhivla_rafsi) { _join(expr) }

extended_rafsi = expr:(brivla_rafsi / fuhivla_rafsi) { _join(expr) }

stressed_brivla_rafsi = expr:(&unstressed_syllable brivla_head stressed_syllable h y) { _join(expr) }

brivla_rafsi = expr:(&(syllable consonantal_syllable* syllable) brivla_head h y h?) { _join(expr) }

stressed_fuhivla_rafsi = expr:(fuhivla_head stressed_syllable &consonant onset y) { _join(expr) }

fuhivla_rafsi = expr:(&unstressed_syllable fuhivla_head &consonant onset y h?) { _join(expr) }

fuhivla_head = expr:(!rafsi_string brivla_head) { _join(expr) }

brivla_head = expr:(!cmavo !slinkuhi !h &onset unstressed_syllable*) { _join(expr) }

slinkuhi = expr:(consonant rafsi_string) { _join(expr) }

rafsi_string = expr:(y_less_rafsi* (gismu / CVV_final_rafsi / stressed_y_less_rafsi short_final_rafsi / y_rafsi / stressed_y_rafsi / stressed_y_less_rafsi? initial_pair y)) { _join(expr) }

//___________________________________________________________________

gismu = expr:(stressed_long_rafsi &final_syllable vowel &post_word) { _join(expr) }

CVV_final_rafsi = expr:(consonant stressed_vowel h &final_syllable vowel &post_word) { _join(expr) }

short_final_rafsi = expr:(&final_syllable (consonant diphthong / initial_pair vowel) &post_word) { _join(expr) }

stressed_y_rafsi = expr:((stressed_long_rafsi / stressed_CVC_rafsi) y) { _join(expr) }

stressed_y_less_rafsi = expr:(stressed_CVC_rafsi !y / stressed_CCV_rafsi / stressed_CVV_rafsi) { _join(expr) }

stressed_long_rafsi = expr:( (stressed_CCV_rafsi / stressed_CVC_rafsi) consonant ) { _join(expr) }

stressed_CVC_rafsi = expr:(consonant stressed_vowel consonant) { _join(expr) }

stressed_CCV_rafsi = expr:(initial_pair stressed_vowel) { _join(expr) }

stressed_CVV_rafsi = expr:(consonant (unstressed_vowel h stressed_vowel / stressed_diphthong) r_hyphen?) { _join(expr) }

y_rafsi = expr:((long_rafsi / CVC_rafsi) y h?) { _join(expr) }

y_less_rafsi = expr:(!y_rafsi (CVC_rafsi !y / CCV_rafsi / CVV_rafsi) !any_extended_rafsi) { _join(expr) }

long_rafsi = expr:((CCV_rafsi / CVC_rafsi) consonant) { _join(expr) }

CVC_rafsi = expr:(consonant unstressed_vowel consonant) { _join(expr) }

CCV_rafsi = expr:(initial_pair unstressed_vowel) { _join(expr) }

CVV_rafsi = expr:(consonant (unstressed_vowel h unstressed_vowel / unstressed_diphthong) r_hyphen?) { _join(expr) }

r_hyphen = expr:(r &consonant / n &r) { _join(expr) }

//___________________________________________________________________

final_syllable = onset !y !stressed nucleus !cmene &post_word

stressed_syllable = &stressed syllable / syllable &stress

stressed_diphthong = &stressed diphthong / diphthong &stress

stressed_vowel = &stressed vowel / vowel &stress

unstressed_syllable = !stressed syllable !stress / consonantal_syllable

unstressed_diphthong = !stressed diphthong !stress

unstressed_vowel = !stressed vowel !stress

stress -memoize = consonant* y? syllable pause

stressed -memoize = onset comma* [AEIOU]

any_syllable -memoize = expr:(onset nucleus coda? / consonantal_syllable) { _join(expr) }

syllable -memoize = onset !y nucleus coda?

consonantal_syllable = consonant syllabic &(consonantal_syllable / onset) (consonant &spaces)?

coda = !any_syllable consonant &any_syllable / syllabic? consonant? &pause

onset -memoize = h / consonant? glide / initial

nucleus -memoize = vowel / diphthong / y !nucleus

//_________________________________________________________________

glide -memoize = (i / u) &nucleus !glide

diphthong = (a i / a u / e i / o i) !nucleus !glide

vowel -memoize = (a / e / i / o / u) !nucleus

a -memoize = comma* [aA] { "a" }

e -memoize = comma* [eE] { "e" }

i -memoize = comma* [iI] { "i" }

o -memoize = comma* [oO] { "o" }

u -memoize = comma* [uU] { "u" }

y -memoize = comma* [yY] { "y" }

//___________________________________________________________________

cluster = "" consonant<2,>

initial_pair = &initial consonant consonant !consonant

initial -memoize = (affricate / sibilant? other? liquid?) !consonant !glide

affricate = t c / t s / d j / d z

liquid -memoize = l / r

other = p / t !l / k / f / x / b / d !l / g / v / m / n !liquid

sibilant = c / s !x / (j / z) !n !liquid

consonant -memoize = voiced / unvoiced / syllabic

syllabic = l / m / n / r

voiced = b / d / g / j / v / z

unvoiced = c / f / k / p / s / t / x

l -memoize = comma* [lL] !h !l { "l" }

m -memoize = comma* [mM] !h !m !z { "m" }

n -memoize = comma* [nN] !h !n !affricate  { "n" }

r -memoize = comma* [rR] !h !r { "r" }

b -memoize = comma* [bB] !h !b !unvoiced { "b" }

d -memoize = comma* [dD] !h !d !unvoiced { "d" }

g -memoize = comma* [gG] !h !g !unvoiced { "g" }

v -memoize = comma* [vV] !h !v !unvoiced { "v" }

j -memoize = comma* [jJ] !h !j !z !unvoiced { "j" }

z -memoize = comma* [zZ] !h !z !j !unvoiced { "z" }

s -memoize = comma* [sS] !h !s !c !voiced { "s" }

c -memoize = comma* [cC] !h !c !s !x !voiced { "c" }

x -memoize = comma* [xX] !h !x !c !k !voiced { "x" }

k -memoize = comma* [kK] !h !k !x !voiced { "k" }

f -memoize = comma* [fF] !h !f !voiced { "f" }

p -memoize = comma* [pP] !h !p !voiced { "p" }

t -memoize = comma* [tT] !h !t !voiced { "t" }

h -memoize = comma* ['h] &nucleus { "'" }

//___________________________________________________________________

digit = comma* [0123456789] !h !nucleus

post_word = pause / !nucleus lojban_word

pause = comma* space_char / EOF

EOF = comma* !.

comma = ","

non_lojban_word = !lojban_word non_space+

non_space = expr:(!space_char .) { _join(expr) }

//Unicode_style and escaped chars not compatible with cl_peg
space_char = [.\t\n\r?!\u0020] { "" }

//___________________________________________________________________

spaces -memoize = !Y expr:initial_spaces  { expr }

initial_spaces = expr:((comma* space_char / !ybu Y)+ EOF? / EOF)  { _join(expr) }

ybu = expr:(Y space_char* BU)  { _join(expr) }

lujvo <object> = expr:(!gismu !fuhivla brivla)  { new { label = "lujvo", arg = expr } }

//___________________________________________________________________

A <object> = &cmavo arg:( a / e / j i / o / u ) &post_word { new { label = "A", arg } }

BAI <object> = &cmavo arg:( d u h o / s i h u / z a u / k i h i / d u h i / c u h u / t u h i / t i h u / d i h o / j i h u / r i h a / n i h i / m u h i / k i h u / v a h u / k o i / c a h i / t a h i / p u h e / j a h i / k a i / b a i / f i h e / d e h i / c i h o / m a u / m u h u / r i h i / r a h i / k a h a / p a h u / p a h a / l e h a / k u h u / t a i / b a u / m a h i / c i h e / f a u / p o h i / c a u / m a h e / c i h u / r a h a / p u h a / l i h e / l a h u / b a h i / k a h i / s a u / f a h e / b e h i / t i h i / j a h e / g a h a / v a h o / j i h o / m e h a / d o h e / j i h e / p i h o / g a u / z u h e / m e h e / r a i ) &post_word { new { label = "BAI", arg } }

BAhE <object> = &cmavo arg:( b a h e / z a h e ) &post_word { new { label = "BAhE", arg } }

BE <object> = &cmavo arg:( b e ) &post_word  { new { label = "BE", arg } }

BEI <object> = &cmavo arg:( b e i ) &post_word { new { label = "BEI", arg } }

BEhO <object> = &cmavo arg:( b e h o ) &post_word { new { label = "BEhO", arg } }

BIhE <object> = &cmavo arg:( b i h e ) &post_word { new { label = "BIhE", arg } }

BIhI <object> = &cmavo arg:( m i h i / b i h o / b i h i ) &post_word { new { label = "BIhI", arg } }

BO <object> = &cmavo arg:( b o ) &post_word  { new { label = "BO", arg } }

BOI <object> = &cmavo arg:( b o i ) &post_word { new { label = "BOI", arg } }

BU <object> = &cmavo arg:( b u ) &post_word { new { label = "BU", arg } }

BY <object> = ybu / &cmavo arg:( j o h o / r u h o / g e h o / j e h o / l o h a / n a h a / s e h e / t o h a / g a h e / y h y / b y / c y / d y / f y / g y / j y / k y / l y / m y / n y / p y / r y / s y / t y / v y / x y / z y ) &post_word { new { label = "BY", arg } }

CAhA <object> = &cmavo arg:( c a h a / p u h i / n u h o / k a h e ) &post_word { new { label = "CAhA", arg } }

CAI <object> = &cmavo arg:( p e i / c a i / c u h i / s a i / r u h e ) &post_word { new { label = "CAI", arg } }

CEI <object> = &cmavo arg:( c e i ) &post_word { new { label = "CEI", arg } }

CEhE <object> = &cmavo arg:( c e h e ) &post_word { new { label = "CEhE", arg } }

CO <object> = &cmavo arg:( c o ) &post_word { new { label = "CO", arg } }

COI <object> = &cmavo arg:( j u h i / c o i / f i h i / t a h a / m u h o / f e h o / c o h o / p e h u / k e h o / n u h e / r e h i / b e h e / j e h e / m i h e / k i h e / v i h o ) &post_word { new { label = "COI", arg } }

CU <object> = &cmavo arg:( c u ) &post_word { new { label = "CU", arg } }

CUhE <object> = &cmavo arg:( c u h e / n a u ) &post_word { new { label = "CUhE", arg } }

DAhO <object> = &cmavo arg:( d a h o ) &post_word { new { label = "DAhO", arg } }

DOI <object> = &cmavo arg:( d o i ) &post_word { new { label = "DOI", arg } }

DOhU <object> = &cmavo arg:( d o h u ) &post_word { new { label = "DOhU", arg } }

FA <object> = &cmavo arg:( f a i / f a / f e / f o / f u / f i h a / f i ) &post_word { new { label = "FA", arg } }

FAhA <object> = &cmavo arg:( d u h a / b e h a / n e h u / v u h a / g a h u / t i h a / n i h a / c a h u / z u h a / r i h u / r u h u / r e h o / t e h e / b u h u / n e h a / p a h o / n e h i / t o h o / z o h i / z e h o / z o h a / f a h a ) &post_word  &post_word { new { label = "FAhA", arg } }

FAhO <object> = &cmavo arg:( f a h o ) &post_word { new { label = "FAhO", arg } }

FEhE <object> = &cmavo arg:( f e h e ) &post_word { new { label = "FEhE", arg } }

FEhU <object> = &cmavo arg:( f e h u ) &post_word { new { label = "FEhU", arg } }

FIhO <object> = &cmavo arg:( f i h o ) &post_word { new { label = "FIhO", arg } }

FOI <object> = &cmavo arg:( f o i ) &post_word { new { label = "FOI", arg } }

FUhA <object> = &cmavo arg:( f u h a ) &post_word { new { label = "FUhA", arg } }

FUhE <object> = &cmavo arg:( f u h e ) &post_word { new { label = "FUhE", arg } }

FUhO <object> = &cmavo arg:( f u h o ) &post_word { new { label = "FUhO", arg } }

GA <object> = &cmavo arg:( g e h i / g e / g o / g a / g u ) &post_word { new { label = "GA", arg } }

GAhO <object> = &cmavo arg:( k e h i / g a h o ) &post_word { new { label = "GAhO", arg } }

GEhU <object> = &cmavo arg:( g e h u ) &post_word { new { label = "GEhU", arg } }

GI <object> = &cmavo arg:( g i ) &post_word { new { label = "GI", arg } }

GIhA <object> = &cmavo arg:( g i h e / g i h i / g i h o / g i h a / g i h u ) &post_word { new { label = "GIhA", arg } }

GOI <object> = &cmavo arg:( n o h u / n e / g o i / p o h u / p e / p o h e / p o ) &post_word { new { label = "GOI", arg } }

GOhA <object> = &cmavo arg:( m o / n e i / g o h u / g o h o / g o h i / n o h a / g o h e / g o h a / d u / b u h a / b u h e / b u h i / c o h e ) &post_word { new { label = "GOhA", arg } } 

GUhA <object> = &cmavo arg:( g u h e / g u h i / g u h o / g u h a / g u h u ) &post_word { new { label = "GUhA", arg } }

I <object> = &cmavo arg:( i ) &post_word { new { label = "I", arg } }

JA <object> = &cmavo arg:( j e h i / j e / j o / j a / j u ) &post_word { new { label = "JA", arg } } 

JAI <object> = &cmavo arg:( j a i ) &post_word { new { label = "JAI", arg } }

JOhI <object> = &cmavo arg:( j o h i ) &post_word { new { label = "JOhI", arg } }

JOI <object> = &cmavo arg:( f a h u / p i h u / j o i / c e h o / c e / j o h u / k u h a / j o h e / j u h e ) &post_word { new { label = "JOI", arg } }

KE <object> = &cmavo arg:( k e ) &post_word { new { label = "KE", arg } }

KEhE <object> = &cmavo arg:( k e h e ) &post_word { new { label = "KEhE", arg } }

KEI <object> = &cmavo arg:( k e i ) &post_word { new { label = "KEI", arg } }

KI <object> = &cmavo arg:( k i ) &post_word { new { label = "KI", arg } }

KOhA <object> = &cmavo arg:( d a h u / d a h e / d i h u / d i h e / d e h u / d e h e / d e i / d o h i / m i h o / m a h a / m i h a / d o h o / k o h a / f o h u / k o h e / k o h i / k o h o / k o h u / f o h a / f o h e / f o h i / f o h o / v o h a / v o h e / v o h i / v o h o / v o h u / r u / r i / r a / t a / t u / t i / z i h o / k e h a / m a / z u h i / z o h e / c e h u / d a / d e / d i / k o / m i / d o ) &post_word { new { label = "KOhA", arg } }

KU <object> = &cmavo arg:( k u ) &post_word { new { label = "KU", arg } }

KUhE <object> = &cmavo arg:( k u h e ) &post_word { new { label = "KUhE", arg } }

KUhO <object> = &cmavo arg:( k u h o ) &post_word { new { label = "KUhO", arg } }

LA <object> = &cmavo arg:( l a i / l a h i / l a ) &post_word { new { label = "LA", arg } }

LAU <object> = &cmavo arg:( c e h a / l a u / z a i / t a u ) &post_word { new { label = "LAU", arg } }

LAhE <object> = &cmavo arg:( t u h a / l u h a / l u h o / l a h e / v u h i / l u h i / l u h e ) &post_word { new { label = "LAhE", arg } }

LE <object> = &cmavo arg:( l e i / l o i / l e h i / l o h i / l e h e / l o h e / l o / l e ) &post_word { new { label = "LE", arg } }

LEhU <object> = &cmavo arg:( l e h u ) &post_word { new { label = "LEhU", arg } }

LI <object> = &cmavo arg:( m e h o / l i ) &post_word { new { label = "LI", arg } }

LIhU <object> = &cmavo arg:( l i h u ) &post_word { new { label = "LIhU", arg } }

LOhO <object> = &cmavo arg:( l o h o ) &post_word { new { label = "LOhO", arg } }

LOhU <object> = &cmavo arg:( l o h u ) &post_word { new { label = "LOhU", arg } }

LU <object> = &cmavo arg:( l u ) &post_word { new { label = "LU", arg } }

LUhU <object> = &cmavo arg:( l u h u ) &post_word { new { label = "LUhU", arg } }

MAhO <object> = &cmavo arg:( m a h o ) &post_word { new { label = "MAhO", arg } }

MAI <object> = &cmavo arg:( m o h o / m a i ) &post_word { new { label = "MAI", arg } }

ME <object> = &cmavo arg:( m e ) &post_word { new { label = "ME", arg } }

MEhU <object> = &cmavo arg:( m e h u ) &post_word { new { label = "MEhU", arg } }

MOhE <object> = &cmavo arg:( m o h e ) &post_word { new { label = "MOhE", arg } }

MOhI <object> = &cmavo arg:( m o h i ) &post_word { new { label = "MOhI", arg } }

MOI <object> = &cmavo arg:( m e i / m o i / s i h e / c u h o / v a h e ) &post_word { new { label = "MOI", arg } }

NA <object> = &cmavo arg:( j a h a / n a ) &post_word { new { label = "MA", arg } }

NAI <object> = &cmavo arg:( n a i ) &post_word { new { label = "NAI", arg } }

NAhE <object> = &cmavo arg:( t o h e / j e h a / n a h e / n o h e ) &post_word { new { label = "NAhE", arg } }

NAhU <object> = &cmavo arg:( n a h u ) &post_word { new { label = "NAhU", arg } }

NIhE <object> = &cmavo arg:( n i h e ) &post_word { new { label = "NIhE", arg } }

NIhO <object> = &cmavo arg:( n i h o / n o h i ) &post_word { new { label = "NIhO", arg } }

NOI <object> = &cmavo arg:( v o i / n o i / p o i ) &post_word { new { label = "NOI", arg } }

NU <object> = &cmavo arg:( n i / d u h u / s i h o / n u / l i h i / k a / j e i / s u h u / z u h o / m u h e / p u h u / z a h i ) &post_word { new { label = "NU", arg } }

NUhA <object> = &cmavo arg:( n u h a ) &post_word { new { label = "NUhA", arg } }

NUhI <object> = &cmavo arg:( n u h i ) &post_word { new { label = "NUhI", arg } }

NUhU <object> = &cmavo arg:( n u h u ) &post_word { new { label = "NUhU", arg } }

PA <object> = &cmavo arg:( d a u / f e i / g a i / j a u / r e i / v a i / p i h e / p i / f i h u / z a h u / m e h i / n i h u / k i h o / c e h i / m a h u / r a h e / d a h a / s o h a / j i h i / s u h o / s u h e / r o / r a u / s o h u / s o h i / s o h e / s o h o / m o h a / d u h e / t e h o / k a h o / c i h i / t u h o / x o / p a i / n o h o / n o / p a / r e / c i / v o / m u / x a / z e / b i / s o / digit ) &post_word { new { label = "PA", arg } }

PEhE <object> = &cmavo arg:( p e h e ) &post_word { new { label = "PEhE", arg } }

PEhO <object> = &cmavo arg:( p e h o ) &post_word { new { label = "PEhO", arg } }

PU <object> = &cmavo arg:( b a / p u / c a ) &post_word { new { label = "PU", arg } }

RAhO <object> = &cmavo arg:( r a h o ) &post_word { new { label = "RAhO", arg } }

ROI <object> = &cmavo arg:( r e h u / r o i ) &post_word { new { label = "ROI", arg } }

SA <object> = &cmavo arg:( s a ) &post_word { new { label = "SA", arg } }

SE <object> = &cmavo arg:( s e / t e / v e / x e ) &post_word { new { label = "SE", arg } }

SEI <object> = &cmavo arg:( s e i / t i h o ) &post_word { new { label = "SEI", arg } }

SEhU <object> = &cmavo arg:( s e h u ) &post_word { new { label = "SEhU", arg } }

SI <object> = &cmavo arg:( s i ) &post_word { new { label = "SI", arg } }

SOI <object> = &cmavo arg:( s o i ) &post_word { new { label = "SOI", arg } }

SU <object> = &cmavo arg:( s u ) &post_word { new { label = "SU", arg } }

TAhE <object> = &cmavo arg:( r u h i / t a h e / d i h i / n a h o ) &post_word { new { label = "TAhE", arg } }

TEhU <object> = &cmavo arg:( t e h u ) &post_word { new { label = "TEhU", arg } }

TEI <object> = &cmavo arg:( t e i ) &post_word { new { label = "TEI", arg } }

TO <object> = &cmavo arg:( t o h i / t o ) &post_word { new { label = "TO", arg } }

TOI <object> = &cmavo arg:( t o i ) &post_word { new { label = "TOI", arg } }

TUhE <object> = &cmavo arg:( t u h e ) &post_word { new { label = "TUhE", arg } }

TUhU <object> = &cmavo arg:( t u h u ) &post_word { new { label = "TUhU", arg } }

UI <object> = &cmavo arg:( i h a / i e / a h e / u h i / i h o / i h e / a h a / i a / o h i / o h e / e h e / o i / u o / e h i / u h o / a u / u a / a h i / i h u / i i / u h a / u i / a h o / a i / a h u / i u / e i / o h o / e h a / u u / o h a / o h u / u h u / e h o / i o / e h u / u e / i h i / u h e / b a h a / j a h o / c a h e / s u h a / t i h e / k a h u / s e h o / z a h a / p e h i / r u h a / j u h a / t a h o / r a h u / l i h a / b a h u / m u h a / d o h a / t o h u / v a h i / p a h e / z u h u / s a h e / l a h a / k e h u / s a h u / d a h i / j e h u / s a h a / k a u / t a h u / n a h i / j o h a / b i h u / l i h o / p a u / m i h u / k u h i / j i h a / s i h a / p o h o / p e h a / r o h i / r o h e / r o h o / r o h u / r o h a / r e h e / l e h o / j u h o / f u h i / d a i / g a h i / z o h o / b e h u / r i h e / s e h i / s e h a / v u h e / k i h a / x u / g e h e / b u h o ) &post_word { new { label = "UI", arg } }

VA <object> = &cmavo arg:( v i / v a / v u ) &post_word { new { label = "VA", arg } }

VAU <object> = &cmavo arg:( v a u ) &post_word { new { label = "VAU", arg } }

VEI <object> = &cmavo arg:( v e i ) &post_word { new { label = "VEI", arg } }

VEhO <object> = &cmavo arg:( v e h o ) &post_word { new { label = "VEhO", arg } }

VUhU <object> = &cmavo arg:( g e h a / f u h u / p i h i / f e h i / v u h u / s u h i / j u h u / g e i / p a h i / f a h i / t e h a / c u h a / v a h a / n e h o / d e h o / f e h a / s a h o / r e h a / r i h o / s a h i / p i h a / s i h i ) &post_word { new { label = "VUhU", arg } }

VEhA <object> = &cmavo arg:( v e h u / v e h a / v e h i / v e h e ) &post_word { new { label = "VEhA", arg } }

VIhA <object> = &cmavo arg:( v i h i / v i h a / v i h u / v i h e ) &post_word { new { label = "VIhA", arg } }

VUhO <object> = &cmavo arg:( v u h o ) &post_word { new { label = "VUhO", arg } }

XI <object> = &cmavo arg:( x i ) &post_word { new { label = "XI", arg } }

Y <object> = &cmavo arg:y+ &post_word { new { label = "Y", arg } }

ZAhO <object> = &cmavo arg:( c o h i / p u h o / c o h u / m o h u / c a h o / c o h a / d e h a / b a h o / d i h a / z a h o ) &post_word { new { label = "ZAhO", arg } }

ZEhA <object> = &cmavo arg:( z e h u / z e h a / z e h i / z e h e ) &post_word { new { label = "ZEhA", arg } }

ZEI <object> = &cmavo arg:( z e i ) &post_word { new { label = "ZEI", arg } }

ZI <object> = &cmavo arg:( z u / z a / z i ) &post_word { new { label = "ZI", arg } }

ZIhE <object> = &cmavo arg:( z i h e ) &post_word { new { label = "ZIhE", arg } }

ZO <object> = &cmavo arg:( z o ) &post_word { new { label = "ZO", arg } }

ZOI <object> = &cmavo arg:( z o i / l a h o ) &post_word { new { label = "ZOI", arg } }

ZOhU <object> = &cmavo arg:( z o h u ) &post_word { new { label = "ZOhU", arg } }
