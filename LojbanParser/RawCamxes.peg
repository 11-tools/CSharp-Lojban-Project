@namespace LojbanParser
@classname Camxes
@using System.Linq;

start = text

// camxes.js.peg
// Copyright (c) 2013, 2014 Masato Hagiwara
// https://github.com/mhagiwara/camxes.js
//
// camxes.js can be used, modified, and re-distributed under MIT license.
// See LICENSE for the details.

// This is a Parsing Expression Grammar for Lojban.
// See http://bford.info/packrat/
//
// All rules have the form:
//
//     name = peg_expression
//
// which means that the grammatical construct "name" is parsed using
// "peg_expression".
//
// 1)  Names in lower case are grammatical constructs.
// 2)  Names in UPPER CASE are selma'o (lexeme) names, and are terminals.
// 3)  Concatenation is expressed by juxtaposition with no operator symbol.
// 4)  / represents *ORDERED* alternation (choice).  If the first
//     option succeeds, the others will never be checked.
// 5)  ? indicates that the element to the left is optional.
// 6)  * represents optional repetition of the construct to the left.
// 7)  + represents one_or_more repetition of the construct to the left.
// 8)  () serves to indicate the grouping of the other operators.
//
// Longest match wins.

// How to compile using Node.js: (Added by Masato Hagiwara)

// // load peg.js and the file system module
// > var PEG = require("pegjs")
// > var fs = require("fs")
// // read peg and build a parser
// > var camxes_peg = fs.readFileSync("/path/to/camxes.js.peg").toString();
// > var camxes = PEG.buildParser(camxes_peg, {cache: true});
// // test it
// > camxes.parse("ko'a broda");
// [ 'text',
//   [ 'text_1',
//     [ 'paragraphs', [Object] ] ] ]
// // write to a file
// > fs.writeFileSync("/path/to/camxes.js", camxes.toSource());


// ___ GRAMMAR ___



text <Node> = expr: (intro_null NAI_clause* text_part_2 (!gek joik_jek)? text_1? faho_clause EOF?) { new Node("text", expr) }

intro_null <Node> = expr: (initial_spaces? su_clause* intro_si_clause) { new Node("intro_null", expr) }

text_part_2 <Node> = expr: ((CMEVLA_clause+ / indicators?) free*) { new Node("text_part_2", expr) }

//; intro_sa_clause = SA_clause+ / any_word_SA_handling !(ZEI_clause SA_clause) intro_sa_clause
intro_si_clause <Node> = expr: (si_clause? SI_clause*) { new Node("intro_si_clause", expr) }
faho_clause <Node> = expr: ((FAhO_clause dot_star)?) { new Node("faho_clause", expr) }

// Please note that the "text_1" item in the text_1 production does
// *not* match the BNF. This is due to a bug in the BNF.  The change
// here was made to match grammar.300
text_1 <Node> = expr: (I_clause (jek / joik)? (stag? BO_clause)? free* text_1? / NIhO_clause+ free* su_clause* paragraphs? / paragraphs) { new Node("text_1", expr) }

paragraphs <Node> = expr: (paragraph? (NIhO_clause+ free* su_clause* paragraphs)?) { new Node("paragraphs", expr) }

paragraph <Node> = expr: ((statement / fragment) (I_clause !jek !joik !joik_jek free* (statement / fragment)?)*) { new Node("paragraph", expr) }

statement <Node> = expr: (statement_1 / prenex statement) { new Node("statement", expr) }

statement_1 <Node> = expr: (statement_2 (I_clause joik_jek statement_2?)*) { new Node("statement_1", expr) }

statement_2 <Node> = expr: (statement_3 (I_clause (jek / joik)? stag? BO_clause free* statement_2?)?) { new Node("statement_2", expr) }

statement_3 <Node> = expr: (sentence / tag? TUhE_clause free* text_1 TUhU_elidible free*) { new Node("statement_3", expr) }

fragment <Node> = expr: (prenex / terms VAU_elidible free* / ek free* / gihek free* / quantifier / NA_clause !JA_clause free* / relative_clauses / links / linkargs) { new Node("fragment", expr) }

prenex <Node> = expr: (terms ZOhU_clause free*) { new Node("prenex", expr) }

//; sentence = (terms CU_clause? free*)? bridi_tail / bridi_tail

sentence <Node> = expr: ((terms bridi_tail_sa* CU_elidible free*)? bridi_tail_sa* bridi_tail) { new Node("sentence", expr) }

sentence_sa <Node> = expr: (sentence_start (!sentence_start (sa_word / SA_clause !sentence_start ) )* SA_clause &text_1) { new Node("sentence_sa", expr) }

sentence_start <Node> = expr: (I_pre / NIhO_pre) { new Node("sentence_start", expr) }

subsentence <Node> = expr: (sentence / prenex subsentence) { new Node("subsentence", expr) }

bridi_tail <Node> = expr: (bridi_tail_1 (gihek stag? KE_clause free* bridi_tail KEhE_elidible free* tail_terms)?) { new Node("bridi_tail", expr) }

bridi_tail_sa <Node> = expr: (bridi_tail_start (term / !bridi_tail_start (sa_word / SA_clause !bridi_tail_start ) )* SA_clause &bridi_tail) { new Node("bridi_tail_sa", expr) }

bridi_tail_start <Node> = expr: (ME_clause / NUhA_clause / NU_clause / NA_clause !KU_clause / NAhE_clause !BO_clause / selbri / tag bridi_tail_start / KE_clause bridi_tail_start / bridi_tail) { new Node("bridi_tail_start", expr) }

bridi_tail_1 <Node> = expr: (bridi_tail_2 (gihek !(stag? BO_clause) !(stag? KE_clause) free* bridi_tail_2 tail_terms)* /* !LR2*/) { new Node("bridi_tail_1", expr) }

bridi_tail_2 <Node> = expr: (bridi_tail_3 (gihek stag? BO_clause free* bridi_tail_2 tail_terms)?) { new Node("bridi_tail_2", expr) }

bridi_tail_3 <Node> = expr: (selbri tail_terms / gek_sentence) { new Node("bridi_tail_3", expr) }

gek_sentence <Node> = expr: (gek subsentence gik subsentence tail_terms / tag* KE_clause free* gek_sentence KEhE_elidible free* / NA_clause free* gek_sentence) { new Node("gek_sentence", expr) }

tail_terms <Node> = expr: (terms? VAU_elidible free*) { new Node("tail_terms", expr) }

terms <Node> = expr: (terms_1+) { new Node("terms", expr) }

//; terms_1 = terms_2 (PEhE_clause free* joik_jek terms_2)*

//; terms_2 = term (CEhE_clause free* term)*

terms_1 <Node> = expr: (terms_2 (pehe_sa* PEhE_clause free* joik_jek terms_2)*) { new Node("terms_1", expr) }

terms_2 <Node> = expr: (term (cehe_sa* CEhE_clause free* nonabs_term)*) { new Node("terms_2", expr) }

pehe_sa <Node> = expr: (PEhE_clause (!PEhE_clause (sa_word / SA_clause !PEhE_clause))* SA_clause) { new Node("pehe_sa", expr) }

cehe_sa <Node> = expr: (CEhE_clause (!CEhE_clause (sa_word / SA_clause !CEhE_clause))* SA_clause) { new Node("cehe_sa", expr) }

//;term = sumti / ( !gek (tag / FA_clause free*) (sumti / KU_elidible free*) ) / termset / NA_clause KU_clause free*

term <Node> = expr: (term_sa* term_1) { new Node("term", expr) }

term_1 <Node> = expr: (sumti / ( !gek (tag !(!tag selbri) / FA_clause free*) (sumti / KU_elidible free*) ) / termset / NA_clause KU_clause free*) { new Node("term_1", expr) }

nonabs_term <Node> = expr: (term_sa* (sumti / ( !gek (tag / FA_clause free*) (sumti / KU_elidible free*) ) / termset / NA_clause KU_clause free*)) { new Node("nonabs_term", expr) }

term_sa <Node> = expr: (term_start (!term_start (sa_word / SA_clause !term_start ) )* SA_clause &term_1) { new Node("term_sa", expr) }

term_start <Node> = expr: (term_1 / LA_clause / LE_clause / LI_clause / LU_clause / LAhE_clause / quantifier term_start / gek sumti gik / FA_clause / tag term_start) { new Node("term_start", expr) }

termset <Node> = expr: (gek_termset / NUhI_clause free* gek terms NUhU_elidible free* gik terms NUhU_elidible free* / NUhI_clause free* terms NUhU_elidible free*) { new Node("termset", expr) }

gek_termset <Node> = expr: (gek terms_gik_terms) { new Node("gek_termset", expr) }

terms_gik_terms <Node> = expr: (nonabs_term (gik / terms_gik_terms) nonabs_term) { new Node("terms_gik_terms", expr) }

sumti <Node> = expr: (sumti_1 (VUhO_clause free* relative_clauses)?) { new Node("sumti", expr) }

sumti_1 <Node> = expr: (sumti_2 (joik_ek stag? KE_clause free* sumti KEhE_elidible free*)?) { new Node("sumti_1", expr) }

sumti_2 <Node> = expr: (sumti_3 (joik_ek sumti_3)* /* !LR2*/) { new Node("sumti_2", expr) }

sumti_3 <Node> = expr: (sumti_4 (joik_ek stag? BO_clause free* sumti_3)?) { new Node("sumti_3", expr) }

sumti_4 <Node> = expr: (sumti_5 / gek sumti gik sumti_4) { new Node("sumti_4", expr) }

sumti_5 <Node> = expr: (quantifier? sumti_6 relative_clauses? / quantifier selbri KU_elidible free* relative_clauses?) { new Node("sumti_5", expr) }

sumti_6 <Node> = expr: (ZO_clause free* / ZOI_clause free* / LOhU_clause free* / lerfu_string !MOI_clause BOI_elidible free* / LU_clause text LIhU_elidible free* / (LAhE_clause free* / NAhE_clause BO_clause free*) relative_clauses? sumti LUhU_elidible free* / KOhA_clause free* / LA_clause free* relative_clauses? CMEVLA_clause+ free* / (LA_clause / LE_clause) free* sumti_tail KU_elidible free* / li_clause) { new Node("sumti_6", expr) }

li_clause <Node> = expr: (LI_clause free* mex LOhO_elidible free*) { new Node("li_clause", expr) }

sumti_tail <Node> = expr: ((sumti_6 relative_clauses?)? sumti_tail_1 / relative_clauses sumti_tail_1) { new Node("sumti_tail", expr) }

sumti_tail_1 <Node> = expr: (selbri relative_clauses? / quantifier selbri relative_clauses? / quantifier sumti) { new Node("sumti_tail_1", expr) }

relative_clauses <Node> = expr: (relative_clause (ZIhE_clause free* relative_clause)*) { new Node("relative_clauses", expr) }

//; relative_clause = GOI_clause free* term GEhU_clause? free* / NOI_clause free* subsentence KUhO_clause? free*

relative_clause <Node> = expr: (relative_clause_sa* relative_clause_1) { new Node("relative_clause", expr) }

relative_clause_sa <Node> = expr: (relative_clause_start (!relative_clause_start (sa_word / SA_clause !relative_clause_start ) )* SA_clause &relative_clause_1) { new Node("relative_clause_sa", expr) }

relative_clause_1 <Node> = expr: (GOI_clause free* nonabs_term GEhU_elidible free* / NOI_clause free* subsentence KUhO_elidible free*) { new Node("relative_clause_1", expr) }

relative_clause_start <Node> = expr: (GOI_clause / NOI_clause) { new Node("relative_clause_start", expr) }

selbri <Node> = expr: (tag? selbri_1) { new Node("selbri", expr) }

selbri_1 <Node> = expr: (selbri_2 / NA_clause free* selbri) { new Node("selbri_1", expr) }

selbri_2 <Node> = expr: (selbri_3 (CO_clause free* selbri_2)?) { new Node("selbri_2", expr) }

selbri_3 <Node> = expr: (selbri_4+ /* !LR*/) { new Node("selbri_3", expr) }

selbri_4 <Node> = expr: (selbri_5 (joik_jek selbri_5 / joik stag? KE_clause free* selbri_3 KEhE_elidible free*)* /* !LR2*/) { new Node("selbri_4", expr) }

selbri_5 <Node> = expr: (selbri_6 ((jek / joik) stag? BO_clause free* selbri_5)?) { new Node("selbri_5", expr) }

selbri_6 <Node> = expr: (tanru_unit (BO_clause free* selbri_6)? / NAhE_clause? free* guhek selbri gik selbri_6) { new Node("selbri_6", expr) }

tanru_unit <Node> = expr: (tanru_unit_1 (CEI_clause free* tanru_unit_1)*) { new Node("tanru_unit", expr) }

tanru_unit_1 <Node> = expr: (tanru_unit_2 linkargs?) { new Node("tanru_unit_1", expr) }

// ** zei is part of BRIVLA_clause
tanru_unit_2 <Node> = expr: (BRIVLA_clause free* / GOhA_clause RAhO_clause? free* / KE_clause free* selbri_3 KEhE_elidible free* / ME_clause free* (sumti / lerfu_string) MEhU_elidible free* MOI_clause? free* / (number / lerfu_string) MOI_clause free* / NUhA_clause free* mex_operator / SE_clause free* tanru_unit_2 / JAI_clause free* tag? tanru_unit_2 / NAhE_clause free* tanru_unit_2 / NU_clause NAI_clause? free* (joik_jek NU_clause NAI_clause? free*)* subsentence KEI_elidible free*) { new Node("tanru_unit_2", expr) }

//; linkargs = BE_clause free* term links? BEhO_clause? free*

linkargs <Node> = expr: (linkargs_sa* linkargs_1) { new Node("linkargs", expr) }

linkargs_1 <Node> = expr: (BE_clause free* nonabs_term links? BEhO_elidible free*) { new Node("linkargs_1", expr) }

linkargs_sa <Node> = expr: (linkargs_start (!linkargs_start (sa_word / SA_clause !linkargs_start ) )* SA_clause &linkargs_1) { new Node("linkargs_sa", expr) }

linkargs_start <Node> = expr: (BE_clause) { new Node("linkargs_start", expr) }

//; links = BEI_clause free* term links?

links <Node> = expr: (links_sa* links_1) { new Node("links", expr) }

links_1 <Node> = expr: (BEI_clause free* nonabs_term links?) { new Node("links_1", expr) }

links_sa <Node> = expr: (links_start (!links_start (sa_word / SA_clause !links_start ) )* SA_clause &links_1) { new Node("links_sa", expr) }

links_start <Node> = expr: (BEI_clause) { new Node("links_start", expr) }

quantifier <Node> = expr: (number !MOI_clause BOI_elidible free* / VEI_clause free* mex VEhO_elidible free*) { new Node("quantifier", expr) }

//;mex = mex_1 (operator mex_1)* / rp_clause

mex <Node> = expr: (mex_sa* mex_0) { new Node("mex", expr) }

mex_0 <Node> = expr: (mex_1 (operator mex_1)* / rp_clause) { new Node("mex_0", expr) }

mex_sa <Node> = expr: (mex_start (!mex_start (sa_word / SA_clause !mex_start) )* SA_clause &mex_0) { new Node("mex_sa", expr) }

mex_start <Node> = expr: (FUhA_clause / PEhO_clause / operand_start) { new Node("mex_start", expr) }

rp_clause <Node> = expr: (FUhA_clause free* rp_expression) { new Node("rp_clause", expr) }

mex_1 <Node> = expr: (mex_2 (BIhE_clause free* operator mex_1)?) { new Node("mex_1", expr) }

mex_2 <Node> = expr: (operand / mex_forethought) { new Node("mex_2", expr) }

// This is just to make for clearer parse trees
mex_forethought <Node> = expr: (PEhO_clause? free* operator fore_operands KUhE_elidible free*) { new Node("mex_forethought", expr) }
fore_operands <Node> = expr: (mex_2+) { new Node("fore_operands", expr) }

//li fu'a reboi ci pi'i voboi mu pi'i su'i reboi ci vu'u su'i du li rexa
//rp_expression = rp_operand rp_operand operator
//rp_operand = operand / rp_expression
// AKA (almost; this one allows a single operand; above does not.
//rp_expression = rp_expression rp_expression operator / operand

// Right recursive version.
rp_expression <Node> = expr: (operand rp_expression_tail) { new Node("rp_expression", expr) }
rp_expression_tail <Node> = expr: (rp_expression operator rp_expression_tail / "") { new Node("rp_expression_tail", expr) }

//; operator = operator_1 (joik_jek operator_1 / joik stag? KE_clause free* operator KEhE_clause? free*)*

operator <Node> = expr: (operator_sa* operator_0) { new Node("operator", expr) }

operator_0 <Node> = expr: (operator_1 (joik_jek operator_1 / joik stag? KE_clause free* operator KEhE_elidible free*)*) { new Node("operator_0", expr) }

operator_sa <Node> = expr: (operator_start (!operator_start (sa_word / SA_clause !operator_start) )* SA_clause &operator_0) { new Node("operator_sa", expr) }

operator_start <Node> = expr: (guhek / KE_clause / SE_clause? NAhE_clause / SE_clause? MAhO_clause / SE_clause? VUhU_clause) { new Node("operator_start", expr) }

operator_1 <Node> = expr: (operator_2 / guhek operator_1 gik operator_2 / operator_2 (jek / joik) stag? BO_clause free* operator_1) { new Node("operator_1", expr) }

operator_2 <Node> = expr: (mex_operator / KE_clause free* operator KEhE_elidible free*) { new Node("operator_2", expr) }

mex_operator <Node> = expr: (SE_clause free* mex_operator / NAhE_clause free* mex_operator / MAhO_clause free* mex TEhU_elidible free* / NAhU_clause free* selbri TEhU_elidible free* / VUhU_clause free*) { new Node("mex_operator", expr) }

//; operand = operand_1 (joik_ek stag? KE_clause free* operand KEhE_clause? free*)?

operand <Node> = expr: (operand_sa* operand_0) { new Node("operand", expr) }

operand_0 <Node> = expr: (operand_1 (joik_ek stag? KE_clause free* operand KEhE_elidible free*)?) { new Node("operand_0", expr) }

operand_sa <Node> = expr: (operand_start (!operand_start (sa_word / SA_clause !operand_start) )* SA_clause &operand_0) { new Node("operand_sa", expr) }

operand_start <Node> = expr: (quantifier / lerfu_word / NIhE_clause / MOhE_clause / JOhI_clause / gek / LAhE_clause / NAhE_clause) { new Node("operand_start", expr) }

operand_1 <Node> = expr: (operand_2 (joik_ek operand_2)*) { new Node("operand_1", expr) }

operand_2 <Node> = expr: (operand_3 (joik_ek stag? BO_clause free* operand_2)?) { new Node("operand_2", expr) }

operand_3 <Node> = expr: (quantifier / lerfu_string !MOI_clause BOI_elidible free* / NIhE_clause free* selbri TEhU_elidible free* / MOhE_clause free* sumti TEhU_elidible free* / JOhI_clause free* mex_2+ TEhU_elidible free* / gek operand gik operand_3 / (LAhE_clause free* / NAhE_clause BO_clause free*) operand LUhU_elidible free*) { new Node("operand_3", expr) }

number <Node> = expr: (PA_clause (PA_clause / lerfu_word)*) { new Node("number", expr) }

lerfu_string <Node> = expr: (lerfu_word (PA_clause / lerfu_word)*) { new Node("lerfu_string", expr) }

// ** BU clauses are part of BY_clause
lerfu_word <Node> = expr: (BY_clause / LAU_clause lerfu_word / TEI_clause lerfu_string FOI_clause) { new Node("lerfu_word", expr) }

ek <Node> = expr: (NA_clause? SE_clause? A_clause NAI_clause?) { new Node("ek", expr) }

//; gihek = NA_clause? SE_clause? GIhA_clause NAI_clause?
gihek <Node> = expr: (gihek_sa* gihek_1) { new Node("gihek", expr) }

gihek_1 <Node> = expr: (NA_clause? SE_clause? GIhA_clause NAI_clause?) { new Node("gihek_1", expr) }

gihek_sa <Node> = expr: (gihek_1 (!gihek_1 (sa_word / SA_clause !gihek_1 ) )* SA_clause &gihek) { new Node("gihek_sa", expr) }

jek <Node> = expr: (NA_clause? SE_clause? JA_clause NAI_clause?) { new Node("jek", expr) }

joik <Node> = expr: (SE_clause? JOI_clause NAI_clause? / interval / GAhO_clause interval GAhO_clause) { new Node("joik", expr) }

interval <Node> = expr: (SE_clause? BIhI_clause NAI_clause?) { new Node("interval", expr) }

//; joik_ek = joik free* / ek free*
joik_ek <Node> = expr: (joik_ek_sa* joik_ek_1) { new Node("joik_ek", expr) }

joik_ek_1 <Node> = expr: (joik free* / ek free*) { new Node("joik_ek_1", expr) }

joik_ek_sa <Node> = expr: (joik_ek_1 (!joik_ek_1 (sa_word / SA_clause !joik_ek_1 ) )* SA_clause &joik_ek) { new Node("joik_ek_sa", expr) }

joik_jek <Node> = expr: (joik free* / jek free*) { new Node("joik_jek", expr) }

gek <Node> = expr: (SE_clause? GA_clause NAI_clause? free* / joik GI_clause free* / stag gik) { new Node("gek", expr) }

guhek <Node> = expr: (SE_clause? GUhA_clause NAI_clause? free*) { new Node("guhek", expr) }

gik <Node> = expr: (GI_clause NAI_clause? free*) { new Node("gik", expr) }

tag <Node> = expr: (tense_modal (joik_jek tense_modal)*) { new Node("tag", expr) }

//stag = simple_tense_modal ((jek / joik) simple_tense_modal)*
stag <Node> = expr: (simple_tense_modal ((jek / joik) simple_tense_modal)* / tense_modal (joik_jek tense_modal)*) { new Node("stag", expr) }

tense_modal <Node> = expr: (simple_tense_modal free* / FIhO_clause free* selbri FEhU_elidible free*) { new Node("tense_modal", expr) }

simple_tense_modal <Node> = expr: (NAhE_clause? SE_clause? BAI_clause NAI_clause? KI_clause? / NAhE_clause? ( ((time space? / space time?) CAhA_clause) / (time space? / space time?) / CAhA_clause ) KI_clause? / KI_clause / CUhE_clause) { new Node("simple_tense_modal", expr) }

time <Node> = expr: (ZI_clause time_offset* (ZEhA_clause (PU_clause NAI_clause?)?)? interval_property* / ZI_clause? time_offset+ (ZEhA_clause (PU_clause NAI_clause?)?)? interval_property* / ZI_clause? time_offset* ZEhA_clause (PU_clause NAI_clause?)? interval_property* / ZI_clause? time_offset* (ZEhA_clause (PU_clause NAI_clause?)?)? interval_property+) { new Node("time", expr) }

time_offset <Node> = expr: (PU_clause NAI_clause? ZI_clause?) { new Node("time_offset", expr) }

space <Node> = expr: (VA_clause space_offset* space_interval? (MOhI_clause space_offset)? / VA_clause? space_offset+ space_interval? (MOhI_clause space_offset)? / VA_clause? space_offset* space_interval (MOhI_clause space_offset)? / VA_clause? space_offset* space_interval? MOhI_clause space_offset) { new Node("space", expr) }

space_offset <Node> = expr: (FAhA_clause NAI_clause? VA_clause?) { new Node("space_offset", expr) }

space_interval <Node> = expr: ((VEhA_clause VIhA_clause? / VIhA_clause) (FAhA_clause NAI_clause?)? space_int_props? / space_int_props) { new Node("space_interval", expr) }

space_int_props <Node> = expr: ((FEhE_clause interval_property)+) { new Node("space_int_props", expr) }

interval_property <Node> = expr: (number ROI_clause NAI_clause? / TAhE_clause NAI_clause? / ZAhO_clause NAI_clause?) { new Node("interval_property", expr) }

free <Node> = expr: (SEI_clause free* (terms CU_elidible free*)? selbri SEhU_elidible / SOI_clause free* sumti sumti? SEhU_elidible / vocative relative_clauses? selbri relative_clauses? DOhU_elidible / vocative relative_clauses? CMEVLA_clause+ free* relative_clauses? DOhU_elidible / vocative sumti? DOhU_elidible / (number / lerfu_string) MAI_clause / TO_clause text TOI_elidible / xi_clause) { new Node("free", expr) }

xi_clause <Node> = expr: (XI_clause free* (number / lerfu_string) BOI_elidible / XI_clause free* VEI_clause free* mex VEhO_elidible) { new Node("xi_clause", expr) }

vocative <Node> = expr: ((COI_clause NAI_clause?)+ DOI_clause / (COI_clause NAI_clause?) (COI_clause NAI_clause?)* / DOI_clause) { new Node("vocative", expr) }

indicators <Node> = expr: (FUhE_clause? indicator+) { new Node("indicators", expr) }

indicator <Node> = expr: (((UI_clause / CAI_clause) NAI_clause? / DAhO_clause / FUhO_clause) !BU_clause) { new Node("indicator", expr) }


// ****************
// Magic Words
// ****************

zei_clause <Node> = expr: (pre_clause zei_clause_no_pre) { new Node("zei_clause", expr) }
zei_clause_no_pre <Node> = expr: (pre_zei_bu (zei_tail? BU_clause+)* zei_tail post_clause /* !LR*/) { new Node("zei_clause_no_pre", expr) }
// zei_clause_no_SA = pre_zei_bu_no_SA (zei_tail? bu_tail)* zei_tail

bu_clause <Node> = expr: (pre_clause bu_clause_no_pre) { new Node("bu_clause", expr) }
bu_clause_no_pre <Node> = expr: (pre_zei_bu (BU_clause* zei_tail)* BU_clause+ post_clause /* !LR*/) { new Node("bu_clause_no_pre", expr) }
// bu_clause_no_SA = pre_zei_bu_no_SA (bu_tail? zei_tail)* bu_tail

zei_tail <Node> = expr: ((ZEI_clause any_word)+) { new Node("zei_tail", expr) }
bu_tail <Node> = expr: (BU_clause+ /* Obsolete: please use BU_clause+ instead for allowing later left_grouping faking.*/) { new Node("bu_tail", expr) }

pre_zei_bu <Node> = expr: (!ZOI_start !BU_clause !ZEI_clause !SI_clause !SA_clause !SU_clause !FAhO_clause any_word_SA_handling si_clause?) { new Node("pre_zei_bu", expr) }
// LOhU_pre / ZO_pre / ZOI_pre / !ZEI_clause !BU_clause !FAhO_clause !SI_clause !SA_clause !SU_clause any_word_SA_handling si_clause?
// pre_zei_bu_no_SA = LOhU_pre / ZO_pre / ZOI_pre / !ZEI_clause !BU_clause !FAhO_clause !SI_clause !SA_clause !SU_clause any_word si_clause?

dot_star <Node> = expr: (.*) { new Node("dot_star", expr) }

// __ General Morphology Issues
//
// 1.  Spaces (including '.y') and UI are eaten *after* a word.
//
// 3.  BAhE is eaten *before* a word.

// Handling of what can go after a cmavo
post_clause <Node> = expr: (spaces? si_clause? !ZEI_clause !BU_clause indicators*) { new Node("post_clause", expr) }

pre_clause <Node> = expr: (BAhE_clause* /* !LR*/) { new Node("pre_clause", expr) }

//any_word_SA_handling = BRIVLA_pre / known_cmavo_SA / !known_cmavo_pre CMAVO_pre / CMEVLA_pre
any_word_SA_handling <Node> = expr: (BRIVLA_pre / known_cmavo_SA / CMAVO_pre / CMEVLA_pre) { new Node("any_word_SA_handling", expr) }

known_cmavo_SA <Node> = expr: (A_pre / BAI_pre / BAhE_pre / BE_pre / BEI_pre / BEhO_pre / BIhE_pre / BIhI_pre / BO_pre / BOI_pre / BU_pre / BY_pre / CAI_pre / CAhA_pre / CEI_pre / CEhE_pre / CO_pre / COI_pre / CU_pre / CUhE_pre / DAhO_pre / DOI_pre / DOhU_pre / FA_pre / FAhA_pre / FEhE_pre / FEhU_pre / FIhO_pre / FOI_pre / FUhA_pre / FUhE_pre / FUhO_pre / GA_pre / GAhO_pre / GEhU_pre / GI_pre / GIhA_pre / GOI_pre / GOhA_pre / GUhA_pre / I_pre / JA_pre / JAI_pre / JOI_pre / JOhI_pre / KE_pre / KEI_pre / KEhE_pre / KI_pre / KOhA_pre / KU_pre / KUhE_pre / KUhO_pre / LA_pre / LAU_pre / LAhE_pre / LE_pre / LEhU_pre / LI_pre / LIhU_pre / LOhO_pre / LOhU_pre / LU_pre / LUhU_pre / MAI_pre / MAhO_pre / ME_pre / MEhU_pre / MOI_pre / MOhE_pre / MOhI_pre / NA_pre / NAI_pre / NAhE_pre / NAhU_pre / NIhE_pre / NIhO_pre / NOI_pre / NU_pre / NUhA_pre / NUhI_pre / NUhU_pre / PA_pre / PEhE_pre / PEhO_pre / PU_pre / RAhO_pre / ROI_pre / SA_pre / SE_pre / SEI_pre / SEhU_pre / SI_clause / SOI_pre / SU_pre / TAhE_pre / TEI_pre / TEhU_pre / TO_pre / TOI_pre / TUhE_pre / TUhU_pre / UI_pre / VA_pre / VAU_pre / VEI_pre / VEhA_pre / VEhO_pre / VIhA_pre / VUhO_pre / VUhU_pre / XI_pre / ZAhO_pre / ZEI_pre / ZEhA_pre / ZI_pre / ZIhE_pre / ZO_pre / ZOI_pre / ZOhU_pre) { new Node("known_cmavo_SA", expr) }

// Handling of spaces and things like spaces.
// ___ SPACE ___
// Do *NOT* delete the line above!

// SU clauses
su_clause <Node> = expr: ((erasable_clause / su_word)* SU_clause) { new Node("su_clause", expr) }

// Handling of SI and interactions with zo and lo'u...le'u

si_clause <Node> = expr: (((erasable_clause / si_word / SA_clause) si_clause? SI_clause)+) { new Node("si_clause", expr) }

erasable_clause <Node> = expr: (bu_clause_no_pre !ZEI_clause !BU_clause / zei_clause_no_pre !ZEI_clause !BU_clause) { new Node("erasable_clause", expr) }

sa_word <Node> = expr: (pre_zei_bu) { new Node("sa_word", expr) }

si_word <Node> = expr: (pre_zei_bu) { new Node("si_word", expr) }

su_word <Node> = expr: (!ZOI_start !NIhO_clause !LU_clause !TUhE_clause !TO_clause !SU_clause !FAhO_clause any_word_SA_handling) { new Node("su_word", expr) }


// ___ ELIDIBLE TERMINATORS ___

BEhO_elidible <Node> = expr: (BEhO_clause?) { new Node("BEhO_elidible", expr) }
BOI_elidible <Node> = expr: (BOI_clause?) { new Node("BOI_elidible", expr) }
CU_elidible <Node> = expr: (CU_clause?) { new Node("CU_elidible", expr) }
DOhU_elidible <Node> = expr: (DOhU_clause?) { new Node("DOhU_elidible", expr) }
FEhU_elidible <Node> = expr: (FEhU_clause?) { new Node("FEhU_elidible", expr) }
// FOI and FUhO are never elidible
GEhU_elidible <Node> = expr: (GEhU_clause?) { new Node("GEhU_elidible", expr) }
KEI_elidible <Node> = expr: (KEI_clause?) { new Node("KEI_elidible", expr) }
KEhE_elidible <Node> = expr: (KEhE_clause?) { new Node("KEhE_elidible", expr) }
KU_elidible <Node> = expr: (KU_clause?) { new Node("KU_elidible", expr) }
KUhE_elidible <Node> = expr: (KUhE_clause?) { new Node("KUhE_elidible", expr) }
KUhO_elidible <Node> = expr: (KUhO_clause?) { new Node("KUhO_elidible", expr) }
// LEhU is never elidible
LIhU_elidible <Node> = expr: (LIhU_clause?) { new Node("LIhU_elidible", expr) }
LOhO_elidible <Node> = expr: (LOhO_clause?) { new Node("LOhO_elidible", expr) }
LUhU_elidible <Node> = expr: (LUhU_clause?) { new Node("LUhU_elidible", expr) }
MEhU_elidible <Node> = expr: (MEhU_clause?) { new Node("MEhU_elidible", expr) }
NUhU_elidible <Node> = expr: (NUhU_clause?) { new Node("NUhU_elidible", expr) }
SEhU_elidible <Node> = expr: (SEhU_clause?) { new Node("SEhU_elidible", expr) }
TEhU_elidible <Node> = expr: (TEhU_clause?) { new Node("TEhU_elidible", expr) }
TOI_elidible <Node> = expr: (TOI_clause?) { new Node("TOI_elidible", expr) }
TUhU_elidible <Node> = expr: (TUhU_clause?) { new Node("TUhU_elidible", expr) }
VAU_elidible <Node> = expr: (VAU_clause?) { new Node("VAU_elidible", expr) }
VEhO_elidible <Node> = expr: (VEhO_clause?) { new Node("VEhO_elidible", expr) }


// ___ SELMAHO ___
// Do *NOT* delete the line above!

BRIVLA_clause <Node> = expr: (BRIVLA_pre BRIVLA_post / zei_clause) { new Node("BRIVLA_clause", expr) }
BRIVLA_pre <Node> = expr: (pre_clause BRIVLA spaces?) { new Node("BRIVLA_pre", expr) }
BRIVLA_post <Node> = expr: (post_clause) { new Node("BRIVLA_post", expr) }
// BRIVLA_no_SA_handling = pre_clause BRIVLA post_clause / zei_clause_no_SA

CMEVLA_clause <Node> = expr: (CMEVLA_pre CMEVLA_post) { new Node("CMEVLA_clause", expr) }
CMEVLA_pre <Node> = expr: (pre_clause CMEVLA spaces?) { new Node("CMEVLA_pre", expr) }
CMEVLA_post <Node> = expr: (post_clause) { new Node("CMEVLA_post", expr) }
// CMEVLA_no_SA_handling = pre_clause CMEVLA post_clause

CMAVO_clause <Node> = expr: (CMAVO_pre CMAVO_post) { new Node("CMAVO_clause", expr) }
CMAVO_pre <Node> = expr: (pre_clause CMAVO spaces?) { new Node("CMAVO_pre", expr) }
CMAVO_post <Node> = expr: (post_clause) { new Node("CMAVO_post", expr) }
// CMAVO_no_SA_handling = pre_clause CMAVO post_clause

//         eks; basic afterthought logical connectives
A_clause <Node> = expr: (A_pre A_post) { new Node("A_clause", expr) }
A_pre <Node> = expr: (pre_clause A spaces?) { new Node("A_pre", expr) }
A_post <Node> = expr: (post_clause) { new Node("A_post", expr) }
// A_no_SA_handling = pre_clause A post_clause


//         modal operators
BAI_clause <Node> = expr: (BAI_pre BAI_post) { new Node("BAI_clause", expr) }
BAI_pre <Node> = expr: (pre_clause BAI spaces?) { new Node("BAI_pre", expr) }
BAI_post <Node> = expr: (post_clause) { new Node("BAI_post", expr) }
// BAI_no_SA_handling = pre_clause BAI post_clause

//         next word intensifier
BAhE_clause <Node> = expr: (BAhE_pre BAhE_post) { new Node("BAhE_clause", expr) }
BAhE_pre <Node> = expr: (BAhE spaces?) { new Node("BAhE_pre", expr) }
BAhE_post <Node> = expr: (si_clause? !ZEI_clause !BU_clause) { new Node("BAhE_post", expr) }
// BAhE_no_SA_handling = BAhE spaces? BAhE_post

//         sumti link to attach sumti to a selbri
BE_clause <Node> = expr: (BE_pre BE_post) { new Node("BE_clause", expr) }
BE_pre <Node> = expr: (pre_clause BE spaces?) { new Node("BE_pre", expr) }
BE_post <Node> = expr: (post_clause) { new Node("BE_post", expr) }
// BE_no_SA_handling = pre_clause BE post_clause

//         multiple sumti separator between BE, BEI
BEI_clause <Node> = expr: (BEI_pre BEI_post) { new Node("BEI_clause", expr) }
BEI_pre <Node> = expr: (pre_clause BEI spaces?) { new Node("BEI_pre", expr) }
BEI_post <Node> = expr: (post_clause) { new Node("BEI_post", expr) }
// BEI_no_SA_handling = pre_clause BEI post_clause

//         terminates BEBEI specified descriptors
BEhO_clause <Node> = expr: (BEhO_pre BEhO_post) { new Node("BEhO_clause", expr) }
BEhO_pre <Node> = expr: (pre_clause BEhO spaces?) { new Node("BEhO_pre", expr) }
BEhO_post <Node> = expr: (post_clause) { new Node("BEhO_post", expr) }
// BEhO_no_SA_handling = pre_clause BEhO post_clause

//         prefix for high_priority MEX operator
BIhE_clause <Node> = expr: (BIhE_pre BIhE_post) { new Node("BIhE_clause", expr) }
BIhE_pre <Node> = expr: (pre_clause BIhE spaces?) { new Node("BIhE_pre", expr) }
BIhE_post <Node> = expr: (post_clause) { new Node("BIhE_post", expr) }
// BIhE_no_SA_handling = pre_clause BIhE post_clause

//         interval component of JOI
BIhI_clause <Node> = expr: (BIhI_pre BIhI_post) { new Node("BIhI_clause", expr) }
BIhI_pre <Node> = expr: (pre_clause BIhI spaces?) { new Node("BIhI_pre", expr) }
BIhI_post <Node> = expr: (post_clause) { new Node("BIhI_post", expr) }
// BIhI_no_SA_handling = pre_clause BIhI post_clause

//         joins two units with shortest scope
BO_clause <Node> = expr: (BO_pre BO_post) { new Node("BO_clause", expr) }
BO_pre <Node> = expr: (pre_clause BO spaces?) { new Node("BO_pre", expr) }
BO_post <Node> = expr: (post_clause) { new Node("BO_post", expr) }
// BO_no_SA_handling = pre_clause BO post_clause

//         number or lerfu_string terminator
BOI_clause <Node> = expr: (BOI_pre BOI_post) { new Node("BOI_clause", expr) }
BOI_pre <Node> = expr: (pre_clause BOI spaces?) { new Node("BOI_pre", expr) }
BOI_post <Node> = expr: (post_clause) { new Node("BOI_post", expr) }
// BOI_no_SA_handling = pre_clause BOI post_clause

//         turns any word into a BY lerfu word
BU_clause <Node> = expr: (BU_pre BU_post) { new Node("BU_clause", expr) }
// BU_clause_no_SA = BU_pre_no_SA BU BU_post
BU_pre <Node> = expr: (pre_clause BU spaces?) { new Node("BU_pre", expr) }
// BU_pre_no_SA = pre_clause
BU_post <Node> = expr: (spaces?) { new Node("BU_post", expr) }
// BU_no_SA_handling = pre_clause BU spaces?

//         individual lerfu words
BY_clause <Node> = expr: (BY_pre BY_post / bu_clause) { new Node("BY_clause", expr) }
BY_pre <Node> = expr: (pre_clause BY spaces?) { new Node("BY_pre", expr) }
BY_post <Node> = expr: (post_clause) { new Node("BY_post", expr) }
// BY_no_SA_handling = pre_clause BY post_clause / bu_clause_no_SA


//         specifies actualitypotentiality of tense
CAhA_clause <Node> = expr: (CAhA_pre CAhA_post) { new Node("CAhA_clause", expr) }
CAhA_pre <Node> = expr: (pre_clause CAhA spaces?) { new Node("CAhA_pre", expr) }
CAhA_post <Node> = expr: (post_clause) { new Node("CAhA_post", expr) }
// CAhA_no_SA_handling = pre_clause CAhA post_clause

//         afterthought intensity marker
CAI_clause <Node> = expr: (CAI_pre CAI_post) { new Node("CAI_clause", expr) }
CAI_pre <Node> = expr: (pre_clause CAI spaces?) { new Node("CAI_pre", expr) }
CAI_post <Node> = expr: (post_clause) { new Node("CAI_post", expr) }
// CAI_no_SA_handling = pre_clause CAI post_clause

//         pro_bridi assignment operator
CEI_clause <Node> = expr: (CEI_pre CEI_post) { new Node("CEI_clause", expr) }
CEI_pre <Node> = expr: (pre_clause CEI spaces?) { new Node("CEI_pre", expr) }
CEI_post <Node> = expr: (post_clause) { new Node("CEI_post", expr) }
// CEI_no_SA_handling = pre_clause CEI post_clause

//         afterthought term list connective
CEhE_clause <Node> = expr: (CEhE_pre CEhE_post) { new Node("CEhE_clause", expr) }
CEhE_pre <Node> = expr: (pre_clause CEhE spaces?) { new Node("CEhE_pre", expr) }
CEhE_post <Node> = expr: (post_clause) { new Node("CEhE_post", expr) }
// CEhE_no_SA_handling = pre_clause CEhE post_clause

//         names; require consonant end, then pause no

//                                    LA or DOI selma'o embedded, pause before if

//                                    vowel initial and preceded by a vowel

//         tanru inversion
CO_clause <Node> = expr: (CO_pre CO_post) { new Node("CO_clause", expr) }
CO_pre <Node> = expr: (pre_clause CO spaces?) { new Node("CO_pre", expr) }
CO_post <Node> = expr: (post_clause) { new Node("CO_post", expr) }
// CO_no_SA_handling = pre_clause CO post_clause

COI_clause <Node> = expr: (COI_pre COI_post) { new Node("COI_clause", expr) }
COI_pre <Node> = expr: (pre_clause COI spaces?) { new Node("COI_pre", expr) }
COI_post <Node> = expr: (post_clause) { new Node("COI_post", expr) }
// COI_no_SA_handling = pre_clause COI post_clause

//         vocative marker permitted inside names; must

//                                    always be followed by pause or DOI

//         separator between head sumti and selbri
CU_clause <Node> = expr: (CU_pre CU_post) { new Node("CU_clause", expr) }
CU_pre <Node> = expr: (pre_clause CU spaces?) { new Node("CU_pre", expr) }
CU_post <Node> = expr: (post_clause) { new Node("CU_post", expr) }
// CU_no_SA_handling = pre_clause CU post_clause

//         tensemodal question
CUhE_clause <Node> = expr: (CUhE_pre CUhE_post) { new Node("CUhE_clause", expr) }
CUhE_pre <Node> = expr: (pre_clause CUhE spaces?) { new Node("CUhE_pre", expr) }
CUhE_post <Node> = expr: (post_clause) { new Node("CUhE_post", expr) }
// CUhE_no_SA_handling = pre_clause CUhE post_clause


//         cancel anaphoracataphora assignments
DAhO_clause <Node> = expr: (DAhO_pre DAhO_post) { new Node("DAhO_clause", expr) }
DAhO_pre <Node> = expr: (pre_clause DAhO spaces?) { new Node("DAhO_pre", expr) }
DAhO_post <Node> = expr: (post_clause) { new Node("DAhO_post", expr) }
// DAhO_no_SA_handling = pre_clause DAhO post_clause

//         vocative marker
DOI_clause <Node> = expr: (DOI_pre DOI_post) { new Node("DOI_clause", expr) }
DOI_pre <Node> = expr: (pre_clause DOI spaces?) { new Node("DOI_pre", expr) }
DOI_post <Node> = expr: (post_clause) { new Node("DOI_post", expr) }
// DOI_no_SA_handling = pre_clause DOI post_clause

//         terminator for DOI_marked vocatives
DOhU_clause <Node> = expr: (DOhU_pre DOhU_post) { new Node("DOhU_clause", expr) }
DOhU_pre <Node> = expr: (pre_clause DOhU spaces?) { new Node("DOhU_pre", expr) }
DOhU_post <Node> = expr: (post_clause) { new Node("DOhU_post", expr) }
// DOhU_no_SA_handling = pre_clause DOhU post_clause


//         modifier head generic case tag
FA_clause <Node> = expr: (FA_pre FA_post) { new Node("FA_clause", expr) }
FA_pre <Node> = expr: (pre_clause FA spaces?) { new Node("FA_pre", expr) }
FA_post <Node> = expr: (post_clause) { new Node("FA_post", expr) }
// FA_no_SA_handling = pre_clause FA post_clause

//         superdirections in space
FAhA_clause <Node> = expr: (FAhA_pre FAhA_post) { new Node("FAhA_clause", expr) }
FAhA_pre <Node> = expr: (pre_clause FAhA spaces?) { new Node("FAhA_pre", expr) }
FAhA_post <Node> = expr: (post_clause) { new Node("FAhA_post", expr) }
// FAhA_no_SA_handling = pre_clause FAhA post_clause


//         normally elided 'done pause' to indicate end
//                                    of utterance string

FAhO_clause <Node> = expr: (pre_clause FAhO spaces?) { new Node("FAhO_clause", expr) }

//         space interval mod flag
FEhE_clause <Node> = expr: (FEhE_pre FEhE_post) { new Node("FEhE_clause", expr) }
FEhE_pre <Node> = expr: (pre_clause FEhE spaces?) { new Node("FEhE_pre", expr) }
FEhE_post <Node> = expr: (post_clause) { new Node("FEhE_post", expr) }
// FEhE_no_SA_handling = pre_clause FEhE post_clause

//         ends bridi to modal conversion
FEhU_clause <Node> = expr: (FEhU_pre FEhU_post) { new Node("FEhU_clause", expr) }
FEhU_pre <Node> = expr: (pre_clause FEhU spaces?) { new Node("FEhU_pre", expr) }
FEhU_post <Node> = expr: (post_clause) { new Node("FEhU_post", expr) }
// FEhU_no_SA_handling = pre_clause FEhU post_clause

//         marks bridi to modal conversion
FIhO_clause <Node> = expr: (FIhO_pre FIhO_post) { new Node("FIhO_clause", expr) }
FIhO_pre <Node> = expr: (pre_clause FIhO spaces?) { new Node("FIhO_pre", expr) }
FIhO_post <Node> = expr: (post_clause) { new Node("FIhO_post", expr) }
// FIhO_no_SA_handling = pre_clause FIhO post_clause

//         end compound lerfu
FOI_clause <Node> = expr: (FOI_pre FOI_post) { new Node("FOI_clause", expr) }
FOI_pre <Node> = expr: (pre_clause FOI spaces?) { new Node("FOI_pre", expr) }
FOI_post <Node> = expr: (post_clause) { new Node("FOI_post", expr) }
// FOI_no_SA_handling = pre_clause FOI post_clause

//         reverse Polish flag
FUhA_clause <Node> = expr: (FUhA_pre FUhA_post) { new Node("FUhA_clause", expr) }
FUhA_pre <Node> = expr: (pre_clause FUhA spaces?) { new Node("FUhA_pre", expr) }
FUhA_post <Node> = expr: (post_clause) { new Node("FUhA_post", expr) }
// FUhA_no_SA_handling = pre_clause FUhA post_clause

//         open long scope for indicator
FUhE_clause <Node> = expr: (FUhE_pre FUhE_post) { new Node("FUhE_clause", expr) }
FUhE_pre <Node> = expr: (pre_clause FUhE spaces?) { new Node("FUhE_pre", expr) }
FUhE_post <Node> = expr: (!BU_clause spaces? !ZEI_clause !BU_clause) { new Node("FUhE_post", expr) }
// FUhE_no_SA_handling = pre_clause FUhE post_clause

//         close long scope for indicator
FUhO_clause <Node> = expr: (FUhO_pre FUhO_post) { new Node("FUhO_clause", expr) }
FUhO_pre <Node> = expr: (pre_clause FUhO spaces?) { new Node("FUhO_pre", expr) }
FUhO_post <Node> = expr: (post_clause) { new Node("FUhO_post", expr) }
// FUhO_no_SA_handling = pre_clause FUhO post_clause


//         geks; forethought logical connectives
GA_clause <Node> = expr: (GA_pre GA_post) { new Node("GA_clause", expr) }
GA_pre <Node> = expr: (pre_clause GA spaces?) { new Node("GA_pre", expr) }
GA_post <Node> = expr: (post_clause) { new Node("GA_post", expr) }
// GA_no_SA_handling = pre_clause GA post_clause

//         openclosed interval markers for BIhI
GAhO_clause <Node> = expr: (GAhO_pre GAhO_post) { new Node("GAhO_clause", expr) }
GAhO_pre <Node> = expr: (pre_clause GAhO spaces?) { new Node("GAhO_pre", expr) }
GAhO_post <Node> = expr: (post_clause) { new Node("GAhO_post", expr) }
// GAhO_no_SA_handling = pre_clause GAhO post_clause

//         marker ending GOI relative clauses
GEhU_clause <Node> = expr: (GEhU_pre GEhU_post) { new Node("GEhU_clause", expr) }
GEhU_pre <Node> = expr: (pre_clause GEhU spaces?) { new Node("GEhU_pre", expr) }
GEhU_post <Node> = expr: (post_clause) { new Node("GEhU_post", expr) }
// GEhU_no_SA_handling = pre_clause GEhU post_clause

//         forethought medial marker
GI_clause <Node> = expr: (GI_pre GI_post) { new Node("GI_clause", expr) }
GI_pre <Node> = expr: (pre_clause GI spaces?) { new Node("GI_pre", expr) }
GI_post <Node> = expr: (post_clause) { new Node("GI_post", expr) }
// GI_no_SA_handling = pre_clause GI post_clause

//         logical connectives for bridi_tails
GIhA_clause <Node> = expr: (GIhA_pre GIhA_post) { new Node("GIhA_clause", expr) }
GIhA_pre <Node> = expr: (pre_clause GIhA spaces?) { new Node("GIhA_pre", expr) }
GIhA_post <Node> = expr: (post_clause) { new Node("GIhA_post", expr) }
// GIhA_no_SA_handling = pre_clause GIhA post_clause

//         attaches a sumti modifier to a sumti
GOI_clause <Node> = expr: (GOI_pre GOI_post) { new Node("GOI_clause", expr) }
GOI_pre <Node> = expr: (pre_clause GOI spaces?) { new Node("GOI_pre", expr) }
GOI_post <Node> = expr: (post_clause) { new Node("GOI_post", expr) }
// GOI_no_SA_handling = pre_clause GOI post_clause

//         pro_bridi
GOhA_clause <Node> = expr: (GOhA_pre GOhA_post) { new Node("GOhA_clause", expr) }
GOhA_pre <Node> = expr: (pre_clause GOhA spaces?) { new Node("GOhA_pre", expr) }
GOhA_post <Node> = expr: (post_clause) { new Node("GOhA_post", expr) }
// GOhA_no_SA_handling = pre_clause GOhA post_clause

//         GEK for tanru units, corresponds to JEKs
GUhA_clause <Node> = expr: (GUhA_pre GUhA_post) { new Node("GUhA_clause", expr) }
GUhA_pre <Node> = expr: (pre_clause GUhA spaces?) { new Node("GUhA_pre", expr) }
GUhA_post <Node> = expr: (post_clause) { new Node("GUhA_post", expr) }
// GUhA_no_SA_handling = pre_clause GUhA post_clause


//         sentence link
I_clause <Node> = expr: (sentence_sa* I_pre I_post) { new Node("I_clause", expr) }
I_pre <Node> = expr: (pre_clause I spaces?) { new Node("I_pre", expr) }
I_post <Node> = expr: (post_clause) { new Node("I_post", expr) }
// I_no_SA_handling = pre_clause I post_clause


//         jeks; logical connectives within tanru
JA_clause <Node> = expr: (JA_pre JA_post) { new Node("JA_clause", expr) }
JA_pre <Node> = expr: (pre_clause JA spaces?) { new Node("JA_pre", expr) }
JA_post <Node> = expr: (post_clause) { new Node("JA_post", expr) }
// JA_no_SA_handling = pre_clause JA post_clause

//         modal conversion flag
JAI_clause <Node> = expr: (JAI_pre JAI_post) { new Node("JAI_clause", expr) }
JAI_pre <Node> = expr: (pre_clause JAI spaces?) { new Node("JAI_pre", expr) }
JAI_post <Node> = expr: (post_clause) { new Node("JAI_post", expr) }
// JAI_no_SA_handling = pre_clause JAI post_clause

//         flags an array operand
JOhI_clause <Node> = expr: (JOhI_pre JOhI_post) { new Node("JOhI_clause", expr) }
JOhI_pre <Node> = expr: (pre_clause JOhI spaces?) { new Node("JOhI_pre", expr) }
JOhI_post <Node> = expr: (post_clause) { new Node("JOhI_post", expr) }
// JOhI_no_SA_handling = pre_clause JOhI post_clause

//         non_logical connectives
JOI_clause <Node> = expr: (JOI_pre JOI_post) { new Node("JOI_clause", expr) }
JOI_pre <Node> = expr: (pre_clause JOI spaces?) { new Node("JOI_pre", expr) }
JOI_post <Node> = expr: (post_clause) { new Node("JOI_post", expr) }
// JOI_no_SA_handling = pre_clause JOI post_clause


//         left long scope marker
KE_clause <Node> = expr: (KE_pre KE_post) { new Node("KE_clause", expr) }
KE_pre <Node> = expr: (pre_clause KE spaces?) { new Node("KE_pre", expr) }
KE_post <Node> = expr: (post_clause) { new Node("KE_post", expr) }
// KE_no_SA_handling = pre_clause KE post_clause

//         right terminator for KE groups
KEhE_clause <Node> = expr: (KEhE_pre KEhE_post) { new Node("KEhE_clause", expr) }
KEhE_pre <Node> = expr: (pre_clause KEhE spaces?) { new Node("KEhE_pre", expr) }
KEhE_post <Node> = expr: (post_clause) { new Node("KEhE_post", expr) }
// KEhE_no_SA_handling = pre_clause KEhE post_clause

//         right terminator, NU abstractions
KEI_clause <Node> = expr: (KEI_pre KEI_post) { new Node("KEI_clause", expr) }
KEI_pre <Node> = expr: (pre_clause KEI spaces?) { new Node("KEI_pre", expr) }
KEI_post <Node> = expr: (post_clause) { new Node("KEI_post", expr) }
KEI_no_SA_handling <Node> = expr: (pre_clause KEI post_clause) { new Node("KEI_no_SA_handling", expr) }

//         multiple utterance scope for tenses
KI_clause <Node> = expr: (KI_pre KI_post) { new Node("KI_clause", expr) }
KI_pre <Node> = expr: (pre_clause KI spaces?) { new Node("KI_pre", expr) }
KI_post <Node> = expr: (post_clause) { new Node("KI_post", expr) }
// KI_no_SA_handling = pre_clause KI post_clause

//         sumti anaphora
KOhA_clause <Node> = expr: (KOhA_pre KOhA_post) { new Node("KOhA_clause", expr) }
KOhA_pre <Node> = expr: (pre_clause KOhA spaces?) { new Node("KOhA_pre", expr) }
KOhA_post <Node> = expr: (post_clause) { new Node("KOhA_post", expr) }
// KOhA_no_SA_handling = pre_clause KOhA spaces?

//         right terminator for descriptions, etc.
KU_clause <Node> = expr: (KU_pre KU_post) { new Node("KU_clause", expr) }
KU_pre <Node> = expr: (pre_clause KU spaces?) { new Node("KU_pre", expr) }
KU_post <Node> = expr: (post_clause) { new Node("KU_post", expr) }
// KU_no_SA_handling = pre_clause KU post_clause

//         MEX forethought delimiter
KUhE_clause <Node> = expr: (KUhE_pre KUhE_post) { new Node("KUhE_clause", expr) }
KUhE_pre <Node> = expr: (pre_clause KUhE spaces?) { new Node("KUhE_pre", expr) }
KUhE_post <Node> = expr: (post_clause) { new Node("KUhE_post", expr) }
// KUhE_no_SA_handling = pre_clause KUhE post_clause

//         right terminator, NOI relative clauses
KUhO_clause <Node> = expr: (KUhO_pre KUhO_post) { new Node("KUhO_clause", expr) }
KUhO_pre <Node> = expr: (pre_clause KUhO spaces?) { new Node("KUhO_pre", expr) }
KUhO_post <Node> = expr: (post_clause) { new Node("KUhO_post", expr) }
// KUhO_no_SA_handling = pre_clause KUhO post_clause


//         name descriptors
LA_clause <Node> = expr: (LA_pre LA_post) { new Node("LA_clause", expr) }
LA_pre <Node> = expr: (pre_clause LA spaces?) { new Node("LA_pre", expr) }
LA_post <Node> = expr: (post_clause) { new Node("LA_post", expr) }
// LA_no_SA_handling = pre_clause LA post_clause

//         lerfu prefixes
LAU_clause <Node> = expr: (LAU_pre LAU_post) { new Node("LAU_clause", expr) }
LAU_pre <Node> = expr: (pre_clause LAU spaces?) { new Node("LAU_pre", expr) }
LAU_post <Node> = expr: (post_clause) { new Node("LAU_post", expr) }
// LAU_no_SA_handling = pre_clause LAU post_clause

//         sumti qualifiers
LAhE_clause <Node> = expr: (LAhE_pre LAhE_post) { new Node("LAhE_clause", expr) }
LAhE_pre <Node> = expr: (pre_clause LAhE spaces?) { new Node("LAhE_pre", expr) }
LAhE_post <Node> = expr: (post_clause) { new Node("LAhE_post", expr) }
// LAhE_no_SA_handling = pre_clause LAhE post_clause

//         sumti descriptors
LE_clause <Node> = expr: (LE_pre LE_post) { new Node("LE_clause", expr) }
LE_pre <Node> = expr: (pre_clause LE spaces?) { new Node("LE_pre", expr) }
LE_post <Node> = expr: (post_clause) { new Node("LE_post", expr) }
// LE_no_SA_handling = pre_clause LE post_clause


//         possibly ungrammatical text right quote
LEhU_clause <Node> = expr: (LEhU_pre LEhU_post) { new Node("LEhU_clause", expr) }
LEhU_pre <Node> = expr: (pre_clause LEhU spaces?) { new Node("LEhU_pre", expr) }
LEhU_post <Node> = expr: (spaces?) { new Node("LEhU_post", expr) }
// LEhU_clause_no_SA = LEhU_pre_no_SA LEhU_post
// LEhU_pre_no_SA = pre_clause LEhU spaces?
// LEhU_no_SA_handling = pre_clause LEhU post_clause

//         convert number to sumti
LI_clause <Node> = expr: (LI_pre LI_post) { new Node("LI_clause", expr) }
LI_pre <Node> = expr: (pre_clause LI spaces?) { new Node("LI_pre", expr) }
LI_post <Node> = expr: (post_clause) { new Node("LI_post", expr) }
// LI_no_SA_handling = pre_clause LI post_clause

//         grammatical text right quote
LIhU_clause <Node> = expr: (LIhU_pre LIhU_post) { new Node("LIhU_clause", expr) }
LIhU_pre <Node> = expr: (pre_clause LIhU spaces?) { new Node("LIhU_pre", expr) }
LIhU_post <Node> = expr: (post_clause) { new Node("LIhU_post", expr) }
// LIhU_no_SA_handling = pre_clause LIhU post_clause

//         elidable terminator for LI
LOhO_clause <Node> = expr: (LOhO_pre LOhO_post) { new Node("LOhO_clause", expr) }
LOhO_pre <Node> = expr: (pre_clause LOhO spaces?) { new Node("LOhO_pre", expr) }
LOhO_post <Node> = expr: (post_clause) { new Node("LOhO_post", expr) }
// LOhO_no_SA_handling = pre_clause LOhO post_clause

//         possibly ungrammatical text left quote
LOhU_clause <Node> = expr: (LOhU_pre LOhU_post) { new Node("LOhU_clause", expr) }
LOhU_pre <Node> = expr: (pre_clause LOhU spaces? (!LEhU any_word)* LEhU_clause spaces?) { new Node("LOhU_pre", expr) }
LOhU_post <Node> = expr: (post_clause) { new Node("LOhU_post", expr) }
// LOhU_no_SA_handling = pre_clause LOhU spaces? (!LEhU any_word)* LEhU_clause spaces?

//         grammatical text left quote
LU_clause <Node> = expr: (LU_pre LU_post) { new Node("LU_clause", expr) }
LU_pre <Node> = expr: (pre_clause LU spaces?) { new Node("LU_pre", expr) }
LU_post <Node> = expr: (spaces? si_clause? !ZEI_clause !BU_clause) { new Node("LU_post", expr) }
// LU_post isn't post_clause for avoiding indicators to attach to LU in the parse tree.
// LU_no_SA_handling = pre_clause LU post_clause

//         LAhE close delimiter
LUhU_clause <Node> = expr: (LUhU_pre LUhU_post) { new Node("LUhU_clause", expr) }
LUhU_pre <Node> = expr: (pre_clause LUhU spaces?) { new Node("LUhU_pre", expr) }
LUhU_post <Node> = expr: (post_clause) { new Node("LUhU_post", expr) }
// LUhU_no_SA_handling = pre_clause LUhU post_clause


//         change MEX expressions to MEX operators
MAhO_clause <Node> = expr: (MAhO_pre MAhO_post) { new Node("MAhO_clause", expr) }
MAhO_pre <Node> = expr: (pre_clause MAhO spaces?) { new Node("MAhO_pre", expr) }
MAhO_post <Node> = expr: (post_clause) { new Node("MAhO_post", expr) }
// MAhO_no_SA_handling = pre_clause MAhO post_clause

//         change numbers to utterance ordinals
MAI_clause <Node> = expr: (MAI_pre MAI_post) { new Node("MAI_clause", expr) }
MAI_pre <Node> = expr: (pre_clause MAI spaces?) { new Node("MAI_pre", expr) }
MAI_post <Node> = expr: (post_clause) { new Node("MAI_post", expr) }
// MAI_no_SA_handling = pre_clause MAI post_clause

//         converts a sumti into a tanru_unit
ME_clause <Node> = expr: (ME_pre ME_post) { new Node("ME_clause", expr) }
ME_pre <Node> = expr: (pre_clause ME spaces?) { new Node("ME_pre", expr) }
ME_post <Node> = expr: (post_clause) { new Node("ME_post", expr) }
// ME_no_SA_handling = pre_clause ME post_clause

//         terminator for ME
MEhU_clause <Node> = expr: (MEhU_pre MEhU_post) { new Node("MEhU_clause", expr) }
MEhU_pre <Node> = expr: (pre_clause MEhU spaces?) { new Node("MEhU_pre", expr) }
MEhU_post <Node> = expr: (post_clause) { new Node("MEhU_post", expr) }
// MEhU_no_SA_handling = pre_clause MEhU post_clause

//         change sumti to operand, inverse of LI
MOhE_clause <Node> = expr: (MOhE_pre MOhE_post) { new Node("MOhE_clause", expr) }
MOhE_pre <Node> = expr: (pre_clause MOhE spaces?) { new Node("MOhE_pre", expr) }
MOhE_post <Node> = expr: (post_clause) { new Node("MOhE_post", expr) }
// MOhE_no_SA_handling = pre_clause MOhE post_clause

//         motion tense marker
MOhI_clause <Node> = expr: (MOhI_pre MOhI_post) { new Node("MOhI_clause", expr) }
MOhI_pre <Node> = expr: (pre_clause MOhI spaces?) { new Node("MOhI_pre", expr) }
MOhI_post <Node> = expr: (post_clause) { new Node("MOhI_post", expr) }
// MOhI_no_SA_handling = pre_clause MOhI post_clause

//         change number to selbri
MOI_clause <Node> = expr: (MOI_pre MOI_post) { new Node("MOI_clause", expr) }
MOI_pre <Node> = expr: (pre_clause MOI spaces?) { new Node("MOI_pre", expr) }
MOI_post <Node> = expr: (post_clause) { new Node("MOI_post", expr) }
// MOI_no_SA_handling = pre_clause MOI post_clause


//         bridi negation
NA_clause <Node> = expr: (NA_pre NA_post) { new Node("NA_clause", expr) }
NA_pre <Node> = expr: (pre_clause NA spaces?) { new Node("NA_pre", expr) }
NA_post <Node> = expr: (post_clause) { new Node("NA_post", expr) }
// NA_no_SA_handling = pre_clause NA post_clause

//         attached to words to negate them
NAI_clause <Node> = expr: (NAI_pre NAI_post) { new Node("NAI_clause", expr) }
NAI_pre <Node> = expr: (pre_clause NAI spaces?) { new Node("NAI_pre", expr) }
NAI_post <Node> = expr: (post_clause) { new Node("NAI_post", expr) }
// NAI_no_SA_handling = pre_clause NAI post_clause

//         scalar negation
NAhE_clause <Node> = expr: (NAhE_pre NAhE_post) { new Node("NAhE_clause", expr) }
NAhE_pre <Node> = expr: (pre_clause NAhE spaces?) { new Node("NAhE_pre", expr) }
NAhE_post <Node> = expr: (post_clause) { new Node("NAhE_post", expr) }
// NAhE_no_SA_handling = pre_clause NAhE post_clause

//         change a selbri into an operator
NAhU_clause <Node> = expr: (NAhU_pre NAhU_post) { new Node("NAhU_clause", expr) }
NAhU_pre <Node> = expr: (pre_clause NAhU spaces?) { new Node("NAhU_pre", expr) }
NAhU_post <Node> = expr: (post_clause) { new Node("NAhU_post", expr) }
// NAhU_no_SA_handling = pre_clause NAhU post_clause

//         change selbri to operand; inverse of MOI
NIhE_clause <Node> = expr: (NIhE_pre NIhE_post) { new Node("NIhE_clause", expr) }
NIhE_pre <Node> = expr: (pre_clause NIhE spaces?) { new Node("NIhE_pre", expr) }
NIhE_post <Node> = expr: (post_clause) { new Node("NIhE_post", expr) }
// NIhE_no_SA_handling = pre_clause NIhE post_clause

//         new paragraph; change of subject
NIhO_clause <Node> = expr: (sentence_sa* NIhO_pre NIhO_post) { new Node("NIhO_clause", expr) }
NIhO_pre <Node> = expr: (pre_clause NIhO spaces?) { new Node("NIhO_pre", expr) }
NIhO_post <Node> = expr: (su_clause* post_clause) { new Node("NIhO_post", expr) }
// NIhO_no_SA_handling = pre_clause NIhO su_clause* post_clause

//         attaches a subordinate clause to a sumti
NOI_clause <Node> = expr: (NOI_pre NOI_post) { new Node("NOI_clause", expr) }
NOI_pre <Node> = expr: (pre_clause NOI spaces?) { new Node("NOI_pre", expr) }
NOI_post <Node> = expr: (post_clause) { new Node("NOI_post", expr) }
// NOI_no_SA_handling = pre_clause NOI post_clause

//         abstraction
NU_clause <Node> = expr: (NU_pre NU_post) { new Node("NU_clause", expr) }
NU_pre <Node> = expr: (pre_clause NU spaces?) { new Node("NU_pre", expr) }
NU_post <Node> = expr: (post_clause) { new Node("NU_post", expr) }
// NU_no_SA_handling = pre_clause NU post_clause

//         change operator to selbri; inverse of MOhE
NUhA_clause <Node> = expr: (NUhA_pre NUhA_post) { new Node("NUhA_clause", expr) }
NUhA_pre <Node> = expr: (pre_clause NUhA spaces?) { new Node("NUhA_pre", expr) }
NUhA_post <Node> = expr: (post_clause) { new Node("NUhA_post", expr) }
// NUhA_no_SA_handling = pre_clause NUhA post_clause

//         marks the start of a termset
NUhI_clause <Node> = expr: (NUhI_pre NUhI_post) { new Node("NUhI_clause", expr) }
NUhI_pre <Node> = expr: (pre_clause NUhI spaces?) { new Node("NUhI_pre", expr) }
NUhI_post <Node> = expr: (post_clause) { new Node("NUhI_post", expr) }
// NUhI_no_SA_handling = pre_clause NUhI post_clause

//         marks the middle and end of a termset
NUhU_clause <Node> = expr: (NUhU_pre NUhU_post) { new Node("NUhU_clause", expr) }
NUhU_pre <Node> = expr: (pre_clause NUhU spaces?) { new Node("NUhU_pre", expr) }
NUhU_post <Node> = expr: (post_clause) { new Node("NUhU_post", expr) }
// NUhU_no_SA_handling = pre_clause NUhU post_clause


//         numbers and numeric punctuation
PA_clause <Node> = expr: (PA_pre PA_post) { new Node("PA_clause", expr) }
PA_pre <Node> = expr: (pre_clause PA spaces?) { new Node("PA_pre", expr) }
PA_post <Node> = expr: (post_clause) { new Node("PA_post", expr) }
// PA_no_SA_handling = pre_clause PA post_clause

//         afterthought termset connective prefix
PEhE_clause <Node> = expr: (PEhE_pre PEhE_post) { new Node("PEhE_clause", expr) }
PEhE_pre <Node> = expr: (pre_clause PEhE spaces?) { new Node("PEhE_pre", expr) }
PEhE_post <Node> = expr: (post_clause) { new Node("PEhE_post", expr) }
// PEhE_no_SA_handling = pre_clause PEhE post_clause

//         forethought (Polish) flag
PEhO_clause <Node> = expr: (PEhO_pre PEhO_post) { new Node("PEhO_clause", expr) }
PEhO_pre <Node> = expr: (pre_clause PEhO spaces?) { new Node("PEhO_pre", expr) }
PEhO_post <Node> = expr: (post_clause) { new Node("PEhO_post", expr) }
// PEhO_no_SA_handling = pre_clause PEhO post_clause

//         directions in time
PU_clause <Node> = expr: (PU_pre PU_post) { new Node("PU_clause", expr) }
PU_pre <Node> = expr: (pre_clause PU spaces?) { new Node("PU_pre", expr) }
PU_post <Node> = expr: (post_clause) { new Node("PU_post", expr) }
// PU_no_SA_handling = pre_clause PU post_clause


//         flag for modified interpretation of GOhI
RAhO_clause <Node> = expr: (RAhO_pre RAhO_post) { new Node("RAhO_clause", expr) }
RAhO_pre <Node> = expr: (pre_clause RAhO spaces?) { new Node("RAhO_pre", expr) }
RAhO_post <Node> = expr: (post_clause) { new Node("RAhO_post", expr) }
// RAhO_no_SA_handling = pre_clause RAhO post_clause

//         converts number to extensional tense
ROI_clause <Node> = expr: (ROI_pre ROI_post) { new Node("ROI_clause", expr) }
ROI_pre <Node> = expr: (pre_clause ROI spaces?) { new Node("ROI_pre", expr) }
ROI_post <Node> = expr: (post_clause) { new Node("ROI_post", expr) }
// ROI_no_SA_handling = pre_clause ROI post_clause

SA_clause <Node> = expr: (SA_pre SA_post) { new Node("SA_clause", expr) }
SA_pre <Node> = expr: (pre_clause SA spaces?) { new Node("SA_pre", expr) }
SA_post <Node> = expr: (spaces?) { new Node("SA_post", expr) }

//         metalinguistic eraser to the beginning of

//                                    the current utterance

//         conversions
SE_clause <Node> = expr: (SE_pre SE_post) { new Node("SE_clause", expr) }
SE_pre <Node> = expr: (pre_clause SE spaces?) { new Node("SE_pre", expr) }
SE_post <Node> = expr: (post_clause) { new Node("SE_post", expr) }
// SE_no_SA_handling = pre_clause SE post_clause

//         metalinguistic bridi insert marker
SEI_clause <Node> = expr: (SEI_pre SEI_post) { new Node("SEI_clause", expr) }
SEI_pre <Node> = expr: (pre_clause SEI spaces?) { new Node("SEI_pre", expr) }
SEI_post <Node> = expr: (post_clause) { new Node("SEI_post", expr) }
// SEI_no_SA_handling = pre_clause SEI post_clause

//         metalinguistic bridi end marker
SEhU_clause <Node> = expr: (SEhU_pre SEhU_post) { new Node("SEhU_clause", expr) }
SEhU_pre <Node> = expr: (pre_clause SEhU spaces?) { new Node("SEhU_pre", expr) }
SEhU_post <Node> = expr: (post_clause) { new Node("SEhU_post", expr) }
// SEhU_no_SA_handling = pre_clause SEhU post_clause

//         metalinguistic single word eraser
SI_clause <Node> = expr: (spaces? SI spaces?) { new Node("SI_clause", expr) }

//         reciprocal sumti marker
SOI_clause <Node> = expr: (SOI_pre SOI_post) { new Node("SOI_clause", expr) }
SOI_pre <Node> = expr: (pre_clause SOI spaces?) { new Node("SOI_pre", expr) }
SOI_post <Node> = expr: (post_clause) { new Node("SOI_post", expr) }
// SOI_no_SA_handling = pre_clause SOI post_clause

//         metalinguistic eraser of the entire text
SU_clause <Node> = expr: (SU_pre SU_post) { new Node("SU_clause", expr) }
SU_pre <Node> = expr: (pre_clause SU spaces?) { new Node("SU_pre", expr) }
SU_post <Node> = expr: (post_clause) { new Node("SU_post", expr) }


//         tense interval properties
TAhE_clause <Node> = expr: (TAhE_pre TAhE_post) { new Node("TAhE_clause", expr) }
TAhE_pre <Node> = expr: (pre_clause TAhE spaces?) { new Node("TAhE_pre", expr) }
TAhE_post <Node> = expr: (post_clause) { new Node("TAhE_post", expr) }
// TAhE_no_SA_handling = pre_clause TAhE post_clause

//         closing gap for MEX constructs
TEhU_clause <Node> = expr: (TEhU_pre TEhU_post) { new Node("TEhU_clause", expr) }
TEhU_pre <Node> = expr: (pre_clause TEhU spaces?) { new Node("TEhU_pre", expr) }
TEhU_post <Node> = expr: (post_clause) { new Node("TEhU_post", expr) }
// TEhU_no_SA_handling = pre_clause TEhU post_clause

//         start compound lerfu
TEI_clause <Node> = expr: (TEI_pre TEI_post) { new Node("TEI_clause", expr) }
TEI_pre <Node> = expr: (pre_clause TEI spaces?) { new Node("TEI_pre", expr) }
TEI_post <Node> = expr: (post_clause) { new Node("TEI_post", expr) }
// TEI_no_SA_handling = pre_clause TEI post_clause

//         left discursive parenthesis
TO_clause <Node> = expr: (TO_pre TO_post) { new Node("TO_clause", expr) }
TO_pre <Node> = expr: (pre_clause TO spaces?) { new Node("TO_pre", expr) }
TO_post <Node> = expr: (post_clause) { new Node("TO_post", expr) }
// TO_no_SA_handling = pre_clause TO post_clause

//         right discursive parenthesis
TOI_clause <Node> = expr: (TOI_pre TOI_post) { new Node("TOI_clause", expr) }
TOI_pre <Node> = expr: (pre_clause TOI spaces?) { new Node("TOI_pre", expr) }
TOI_post <Node> = expr: (post_clause) { new Node("TOI_post", expr) }
// TOI_no_SA_handling = pre_clause TOI post_clause

//         multiple utterance scope mark
TUhE_clause <Node> = expr: (TUhE_pre TUhE_post) { new Node("TUhE_clause", expr) }
TUhE_pre <Node> = expr: (pre_clause TUhE spaces?) { new Node("TUhE_pre", expr) }
TUhE_post <Node> = expr: (su_clause* post_clause) { new Node("TUhE_post", expr) }
// TUhE_no_SA_handling = pre_clause TUhE su_clause* post_clause

//         multiple utterance end scope mark
TUhU_clause <Node> = expr: (TUhU_pre TUhU_post) { new Node("TUhU_clause", expr) }
TUhU_pre <Node> = expr: (pre_clause TUhU spaces?) { new Node("TUhU_pre", expr) }
TUhU_post <Node> = expr: (post_clause) { new Node("TUhU_post", expr) }
// TUhU_no_SA_handling = pre_clause TUhU post_clause


//         attitudinals, observationals, discursives
UI_clause <Node> = expr: (UI_pre UI_post) { new Node("UI_clause", expr) }
UI_pre <Node> = expr: (pre_clause UI spaces?) { new Node("UI_pre", expr) }
UI_post <Node> = expr: (post_clause) { new Node("UI_post", expr) }
// UI_no_SA_handling = pre_clause UI post_clause


//         distance in space_time
VA_clause <Node> = expr: (VA_pre VA_post) { new Node("VA_clause", expr) }
VA_pre <Node> = expr: (pre_clause VA spaces?) { new Node("VA_pre", expr) }
VA_post <Node> = expr: (post_clause) { new Node("VA_post", expr) }
// VA_no_SA_handling = pre_clause VA post_clause

//         end simple bridi or bridi_tail
VAU_clause <Node> = expr: (VAU_pre VAU_post) { new Node("VAU_clause", expr) }
VAU_pre <Node> = expr: (pre_clause VAU spaces?) { new Node("VAU_pre", expr) }
VAU_post <Node> = expr: (post_clause) { new Node("VAU_post", expr) }
// VAU_no_SA_handling = pre_clause VAU post_clause

//         left MEX bracket
VEI_clause <Node> = expr: (VEI_pre VEI_post) { new Node("VEI_clause", expr) }
VEI_pre <Node> = expr: (pre_clause VEI spaces?) { new Node("VEI_pre", expr) }
VEI_post <Node> = expr: (post_clause) { new Node("VEI_post", expr) }
// VEI_no_SA_handling = pre_clause VEI post_clause

//         right MEX bracket
VEhO_clause <Node> = expr: (VEhO_pre VEhO_post) { new Node("VEhO_clause", expr) }
VEhO_pre <Node> = expr: (pre_clause VEhO spaces?) { new Node("VEhO_pre", expr) }
VEhO_post <Node> = expr: (post_clause) { new Node("VEhO_post", expr) }
// VEhO_no_SA_handling = pre_clause VEhO post_clause

//         MEX operator
VUhU_clause <Node> = expr: (VUhU_pre VUhU_post) { new Node("VUhU_clause", expr) }
VUhU_pre <Node> = expr: (pre_clause VUhU spaces?) { new Node("VUhU_pre", expr) }
VUhU_post <Node> = expr: (post_clause) { new Node("VUhU_post", expr) }
// VUhU_no_SA_handling = pre_clause VUhU post_clause

//         space_time interval size
VEhA_clause <Node> = expr: (VEhA_pre VEhA_post) { new Node("VEhA_clause", expr) }
VEhA_pre <Node> = expr: (pre_clause VEhA spaces?) { new Node("VEhA_pre", expr) }
VEhA_post <Node> = expr: (post_clause) { new Node("VEhA_post", expr) }
// VEhA_no_SA_handling = pre_clause VEhA post_clause

//         space_time dimensionality marker
VIhA_clause <Node> = expr: (VIhA_pre VIhA_post) { new Node("VIhA_clause", expr) }
VIhA_pre <Node> = expr: (pre_clause VIhA spaces?) { new Node("VIhA_pre", expr) }
VIhA_post <Node> = expr: (post_clause) { new Node("VIhA_post", expr) }
// VIhA_no_SA_handling = pre_clause VIhA post_clause

VUhO_clause <Node> = expr: (VUhO_pre VUhO_post) { new Node("VUhO_clause", expr) }
VUhO_pre <Node> = expr: (pre_clause VUhO spaces?) { new Node("VUhO_pre", expr) }
VUhO_post <Node> = expr: (post_clause) { new Node("VUhO_post", expr) }
// VUhO_no_SA_handling = pre_clause VUhO post_clause

// glue between logically connected sumti and relative clauses


//         subscripting operator
XI_clause <Node> = expr: (XI_pre XI_post) { new Node("XI_clause", expr) }
XI_pre <Node> = expr: (pre_clause XI spaces?) { new Node("XI_pre", expr) }
XI_post <Node> = expr: (post_clause) { new Node("XI_post", expr) }
// XI_no_SA_handling = pre_clause XI post_clause


//         hesitation
// Very very special case.  Handled in the morphology section.
// Y_clause = spaces? Y spaces?


//         event properties _ inchoative, etc.
ZAhO_clause <Node> = expr: (ZAhO_pre ZAhO_post) { new Node("ZAhO_clause", expr) }
ZAhO_pre <Node> = expr: (pre_clause ZAhO spaces?) { new Node("ZAhO_pre", expr) }
ZAhO_post <Node> = expr: (post_clause) { new Node("ZAhO_post", expr) }
// ZAhO_no_SA_handling = pre_clause ZAhO post_clause

//         time interval size tense
ZEhA_clause <Node> = expr: (ZEhA_pre ZEhA_post) { new Node("ZEhA_clause", expr) }
ZEhA_pre <Node> = expr: (pre_clause ZEhA spaces?) { new Node("ZEhA_pre", expr) }
ZEhA_post <Node> = expr: (post_clause) { new Node("ZEhA_post", expr) }
// ZEhA_no_SA_handling = pre_clause ZEhA post_clause

//         lujvo glue
ZEI_clause <Node> = expr: (ZEI_pre ZEI_post) { new Node("ZEI_clause", expr) }
// ZEI_clause_no_SA = ZEI_pre_no_SA ZEI ZEI_post
ZEI_pre <Node> = expr: (pre_clause ZEI spaces?) { new Node("ZEI_pre", expr) }
// ZEI_pre_no_SA = pre_clause
ZEI_post <Node> = expr: (spaces?) { new Node("ZEI_post", expr) }
// ZEI_no_SA_handling = pre_clause ZEI post_clause

//         time distance tense
ZI_clause <Node> = expr: (ZI_pre ZI_post) { new Node("ZI_clause", expr) }
ZI_pre <Node> = expr: (pre_clause ZI spaces?) { new Node("ZI_pre", expr) }
ZI_post <Node> = expr: (post_clause) { new Node("ZI_post", expr) }
// ZI_no_SA_handling = pre_clause ZI post_clause

//         conjoins relative clauses
ZIhE_clause <Node> = expr: (ZIhE_pre ZIhE_post) { new Node("ZIhE_clause", expr) }
ZIhE_pre <Node> = expr: (pre_clause ZIhE spaces?) { new Node("ZIhE_pre", expr) }
ZIhE_post <Node> = expr: (post_clause) { new Node("ZIhE_post", expr) }
// ZIhE_no_SA_handling = pre_clause ZIhE post_clause

//         single word metalinguistic quote marker
ZO_clause <Node> = expr: (ZO_pre ZO_post) { new Node("ZO_clause", expr) }
ZO_pre <Node> = expr: (pre_clause ZO spaces? any_word spaces?) { new Node("ZO_pre", expr) }
ZO_post <Node> = expr: (post_clause) { new Node("ZO_post", expr) }
// ZO_no_SA_handling = pre_clause ZO spaces? any_word spaces?

//         delimited quote marker
ZOI_clause <Node> = expr: (ZOI_pre ZOI_post) { new Node("ZOI_clause", expr) }
ZOI_pre <Node> = expr: (pre_clause ZOI spaces? zoi_open spaces? (zoi_word spaces)* zoi_close spaces?) { new Node("ZOI_pre", expr) }
ZOI_post <Node> = expr: (post_clause) { new Node("ZOI_post", expr) }
ZOI_start <Node> = expr: (!ZOI_pre ZOI) { new Node("ZOI_start", expr) }
// ZOI_no_SA_handling = pre_clause ZOI spaces? zoi_open zoi_word* zoi_close spaces?

//         prenex terminator (not elidable)
ZOhU_clause <Node> = expr: (ZOhU_pre ZOhU_post) { new Node("ZOhU_clause", expr) }
ZOhU_pre <Node> = expr: (pre_clause ZOhU spaces?) { new Node("ZOhU_pre", expr) }
ZOhU_post <Node> = expr: (post_clause) { new Node("ZOhU_post", expr) }
// ZOhU_no_SA_handling = pre_clause ZOhU post_clause


// ___ MORPHOLOGY ___

CMEVLA <Node> = expr: (cmevla) { new Node("CMEVLA", expr) }
BRIVLA <Node> = expr: (gismu / lujvo / fuhivla) { new Node("BRIVLA", expr) }

CMAVO <Node> = expr: (A / BAI / BAhE / BE / BEI / BEhO / BIhE / BIhI / BO / BOI / BU / BY / CAhA / CAI / CEI / CEhE / CO / COI / CU / CUhE / DAhO / DOI / DOhU / FA / FAhA / FAhO / FEhE / FEhU / FIhO / FOI / FUhA / FUhE / FUhO / GA / GAhO / GEhU / GI / GIhA / GOI / GOhA / GUhA / I / JA / JAI / JOhI / JOI / KE / KEhE / KEI / KI / KOhA / KU / KUhE / KUhO / LA / LAU / LAhE / LE / LEhU / LI / LIhU / LOhO / LOhU / LU / LUhU / MAhO / MAI / ME / MEhU / MOhE / MOhI / MOI / NA / NAI / NAhE / NAhU / NIhE / NIhO / NOI / NU / NUhA / NUhI / NUhU / PA / PEhE / PEhO / PU / RAhO / ROI / SA / SE / SEI / SEhU / SI / SOI / SU / TAhE / TEhU / TEI / TO / TOI / TUhE / TUhU / UI / VA / VAU / VEI / VEhO / VUhU / VEhA / VIhA / VUhO / XI / ZAhO / ZEhA / ZEI / ZI / ZIhE / ZO / ZOI / ZOhU / cmavo) { new Node("CMAVO", expr) }

// This is a Parsing Expression Grammar for the morphology of Lojban.
// See http://www.pdos.lcs.mit.edu/~baford/packrat/
//
// All rules have the form
//
// name = peg_expression
//
// which means that the grammatical construct "name" is parsed using
// "peg_expression".
//
// 1) Concatenation is expressed by juxtaposition with no operator symbol.
// 2) / represents *ORDERED* alternation (choice). If the first
// option succeeds, the others will never be checked.
// 3) ? indicates that the element to the left is optional.
// 4) * represents optional repetition of the construct to the left.
// 5) + represents one_or_more repetition of the construct to the left.
// 6) () serves to indicate the grouping of the other operators.
// 7) & indicates that the element to the right must follow (but the
// marked element itself does not absorb anything).
// 8) ! indicates that the element to the right must not follow (the
// marked element itself does not absorb anything).
// 9) . represents any character.
// 10) ' ' or " " represents a literal string.
// 11) [] represents a character class.
//
// Repetitions grab as much as they can.
//
//
// ___ GRAMMAR ___
// This grammar classifies words by their morphological class (cmevla,
// gismu, lujvo, fuhivla, cmavo, and non_lojban_word).
//
//The final section sorts cmavo into grammatical classes (A, BAI, BAhE, ..., ZOhU).
//
// mi'e ((xorxes))

//___________________________________________________________________

// words = expr:(pause? (word pause?)*) { return _join(expr); }

// word = expr:lojban_word / non_lojban_word { return expr; }

// lojban_word = expr:(cmevla / cmavo / brivla) { return expr; }
lojban_word <Node> = expr: (CMEVLA / CMAVO / BRIVLA) { new Node("lojban_word", expr) }

any_word <Node> = expr: (lojban_word spaces?) { new Node("any_word", expr) }

// === ZOI quote handling ===

// Pure PEG cannot handle ZOI quotes, because it cannot check whether the closing
// delimiter is the same as the opening one.
// ZOI quote handling is the only part of Lojban's grammar that needs mechanisms
// external to the pure PEG grammar to be implemented properly; those mechanisms
// are implementation-specific.

zoi_open <Node> = expr: (lojban_word) { new Node("zoi_open", expr) }
// Non-PEG: Remember the value matched by this zoi_open.

zoi_word <Node> = expr: (non_space+) { new Node("zoi_word", expr) }
// Non-PEG: Match successfully only if different from the most recent zoi_open.

zoi_close <Node> = expr: (any_word) { new Node("zoi_close", expr) }
// Non-PEG: Match successfully only if identical to the most recent zoi_open.

//___________________________________________________________________

cmevla <Node> = expr: (jbocme / zifcme) { new Node("cmevla", expr) }

zifcme <Node> = expr: (!h (nucleus / glide / h / consonant !pause / digit)* consonant &pause) { new Node("zifcme", expr) }

jbocme <Node> = expr: (&zifcme (any_syllable / digit)* &pause) { new Node("jbocme", expr) }

//cmevla = !h cmevla_syllable* &consonant coda? consonantal_syllable* onset &pause

//cmevla_syllable = !doi_la_lai_lahi coda? consonantal_syllable* onset nucleus / digit

//doi_la_lai_lahi = (d o i / l a (h? i)?) !h !nucleus

//___________________________________________________________________

cmavo <Node> = expr: (!cmevla !CVCy_lujvo cmavo_form &post_word) { new Node("cmavo", expr) }

CVCy_lujvo <Node> = expr: (CVC_rafsi y h? initial_rafsi* brivla_core / stressed_CVC_rafsi y short_final_rafsi) { new Node("CVCy_lujvo", expr) }

cmavo_form <Node> = expr: (!h !cluster onset (nucleus h)* (!stressed nucleus / nucleus !cluster) / y+ / digit) { new Node("cmavo_form", expr) }

//___________________________________________________________________

brivla <Node> = expr: (!cmavo initial_rafsi* brivla_core) { new Node("brivla", expr) }

brivla_core <Node> = expr: (fuhivla / gismu / CVV_final_rafsi / stressed_initial_rafsi short_final_rafsi) { new Node("brivla_core", expr) }

stressed_initial_rafsi <Node> = expr: (stressed_extended_rafsi / stressed_y_rafsi / stressed_y_less_rafsi) { new Node("stressed_initial_rafsi", expr) }

initial_rafsi <Node> = expr: (extended_rafsi / y_rafsi / !any_extended_rafsi y_less_rafsi !any_extended_rafsi) { new Node("initial_rafsi", expr) }

//___________________________________________________________________

any_extended_rafsi <Node> = expr: (fuhivla / extended_rafsi / stressed_extended_rafsi) { new Node("any_extended_rafsi", expr) }

fuhivla <Node> = expr: (fuhivla_head stressed_syllable consonantal_syllable* final_syllable) { new Node("fuhivla", expr) }

stressed_extended_rafsi <Node> = expr: (stressed_brivla_rafsi / stressed_fuhivla_rafsi) { new Node("stressed_extended_rafsi", expr) }

extended_rafsi <Node> = expr: (brivla_rafsi / fuhivla_rafsi) { new Node("extended_rafsi", expr) }

stressed_brivla_rafsi <Node> = expr: (&unstressed_syllable brivla_head stressed_syllable h y) { new Node("stressed_brivla_rafsi", expr) }

brivla_rafsi <Node> = expr: (&(syllable consonantal_syllable* syllable) brivla_head h y h?) { new Node("brivla_rafsi", expr) }

stressed_fuhivla_rafsi <Node> = expr: (fuhivla_head stressed_syllable consonantal_syllable* !h onset y) { new Node("stressed_fuhivla_rafsi", expr) }

fuhivla_rafsi <Node> = expr: (&unstressed_syllable fuhivla_head !h onset y h?) { new Node("fuhivla_rafsi", expr) }

fuhivla_head <Node> = expr: (!rafsi_string brivla_head) { new Node("fuhivla_head", expr) }

brivla_head <Node> = expr: (!cmavo !slinkuhi !h &onset unstressed_syllable*) { new Node("brivla_head", expr) }

slinkuhi <Node> = expr: (!rafsi_string consonant rafsi_string) { new Node("slinkuhi", expr) }

rafsi_string <Node> = expr: (y_less_rafsi* (gismu / CVV_final_rafsi / stressed_y_less_rafsi short_final_rafsi / y_rafsi / stressed_y_rafsi / stressed_y_less_rafsi? initial_pair y / hy_rafsi / stressed_hy_rafsi)) { new Node("rafsi_string", expr) }

//___________________________________________________________________

gismu <Node> = expr: ((initial_pair stressed_vowel / consonant stressed_vowel consonant) &final_syllable consonant vowel &post_word) { new Node("gismu", expr) }

CVV_final_rafsi <Node> = expr: (consonant stressed_vowel h &final_syllable vowel &post_word) { new Node("CVV_final_rafsi", expr) }

short_final_rafsi <Node> = expr: (&final_syllable (consonant diphthong / initial_pair vowel) &post_word) { new Node("short_final_rafsi", expr) }

stressed_y_rafsi <Node> = expr: ((stressed_long_rafsi / stressed_CVC_rafsi) y) { new Node("stressed_y_rafsi", expr) }

stressed_y_less_rafsi <Node> = expr: (stressed_CVC_rafsi !y / stressed_CCV_rafsi / stressed_CVV_rafsi) { new Node("stressed_y_less_rafsi", expr) }

stressed_long_rafsi <Node> = expr: (initial_pair stressed_vowel consonant / consonant stressed_vowel consonant consonant) { new Node("stressed_long_rafsi", expr) }

stressed_CVC_rafsi <Node> = expr: (consonant stressed_vowel consonant) { new Node("stressed_CVC_rafsi", expr) }

stressed_CCV_rafsi <Node> = expr: (initial_pair stressed_vowel) { new Node("stressed_CCV_rafsi", expr) }

stressed_CVV_rafsi <Node> = expr: (consonant (unstressed_vowel h stressed_vowel / stressed_diphthong) r_hyphen?) { new Node("stressed_CVV_rafsi", expr) }

y_rafsi <Node> = expr: ((long_rafsi / CVC_rafsi) y h?) { new Node("y_rafsi", expr) }

y_less_rafsi <Node> = expr: (!y_rafsi !stressed_y_rafsi !hy_rafsi !stressed_hy_rafsi (CVC_rafsi / CCV_rafsi / CVV_rafsi) !h) { new Node("y_less_rafsi", expr) }

hy_rafsi <Node> = expr: ((long_rafsi vowel / CCV_rafsi / CVV_rafsi) h y h?) { new Node("hy_rafsi", expr) }

stressed_hy_rafsi <Node> = expr: ((long_rafsi stressed_vowel / stressed_CCV_rafsi / stressed_CVV_rafsi) h y) { new Node("stressed_hy_rafsi", expr) }

long_rafsi <Node> = expr: (initial_pair unstressed_vowel consonant / consonant unstressed_vowel consonant consonant) { new Node("long_rafsi", expr) }

CVC_rafsi <Node> = expr: (consonant unstressed_vowel consonant) { new Node("CVC_rafsi", expr) }

CCV_rafsi <Node> = expr: (initial_pair unstressed_vowel) { new Node("CCV_rafsi", expr) }

CVV_rafsi <Node> = expr: (consonant (unstressed_vowel h unstressed_vowel / unstressed_diphthong) r_hyphen?) { new Node("CVV_rafsi", expr) }

r_hyphen <Node> = expr: (r &consonant / n &r) { new Node("r_hyphen", expr) }

//___________________________________________________________________

final_syllable <Node> = expr: (onset !y !stressed nucleus !cmevla &post_word) { new Node("final_syllable", expr) }

stressed_syllable <Node> = expr: (&stressed syllable / syllable &stress) { new Node("stressed_syllable", expr) }

stressed_diphthong <Node> = expr: (&stressed diphthong / diphthong &stress) { new Node("stressed_diphthong", expr) }

stressed_vowel <Node> = expr: (&stressed vowel / vowel &stress) { new Node("stressed_vowel", expr) }

unstressed_syllable <Node> = expr: (!stressed syllable !stress / consonantal_syllable) { new Node("unstressed_syllable", expr) }

unstressed_diphthong <Node> = expr: (!stressed diphthong !stress) { new Node("unstressed_diphthong", expr) }

unstressed_vowel <Node> = expr: (!stressed vowel !stress) { new Node("unstressed_vowel", expr) }

//// FIX: Xorxes' fix for fu'ivla rafsi stress
stress <Node> = expr: ((consonant / glide)* h? y? syllable pause) { new Node("stress", expr) }

stressed <Node> = expr: (onset comma* [AEIOU]) { new Node("stressed", expr) }

any_syllable <Node> = expr: (onset nucleus coda? / consonantal_syllable) { new Node("any_syllable", expr) }

syllable <Node> = expr: (onset !y nucleus coda?) { new Node("syllable", expr) }

//// FIX: preventing {bla'ypre} from being a valid lujvo
consonantal_syllable <Node> = expr: (consonant &syllabic coda) { new Node("consonantal_syllable", expr) }

coda <Node> = expr: (!any_syllable consonant &any_syllable / syllabic? consonant? &pause) { new Node("coda", expr) }

onset <Node> = expr: (h / glide / initial) { new Node("onset", expr) }

nucleus <Node> = expr: (vowel / diphthong / y !nucleus) { new Node("nucleus", expr) }

//_________________________________________________________________

glide <Node> = expr: ((i / u) &nucleus) { new Node("glide", expr) }

diphthong <Node> = expr: ((a i !i / a u !u / e i !i / o i !i) !nucleus) { new Node("diphthong", expr) }

vowel <Node> = expr: ((a / e / i / o / u) !nucleus) { new Node("vowel", expr) }

a <Node> = expr: (comma* [aA]) { new Node("a", expr) }

e <Node> = expr: (comma* [eE]) { new Node("e", expr) }

i <Node> = expr: (comma* [iI]) { new Node("i", expr) }

o <Node> = expr: (comma* [oO]) { new Node("o", expr) }

u <Node> = expr: (comma* [uU]) { new Node("u", expr) }

y <Node> = expr: (comma* [yY] !(!y nucleus)) { new Node("y", expr) }



//___________________________________________________________________

cluster <Node> = expr: (consonant consonant+) { new Node("cluster", expr) }

initial_pair <Node> = expr: (&initial consonant consonant !consonant) { new Node("initial_pair", expr) }

initial <Node> = expr: ((affricate / sibilant? other? liquid?) !consonant !glide) { new Node("initial", expr) }

affricate <Node> = expr: (t c / t s / d j / d z) { new Node("affricate", expr) }

liquid <Node> = expr: (l / r) { new Node("liquid", expr) }

other <Node> = expr: (p / t !l / k / f / x / b / d !l / g / v / m / n !liquid) { new Node("other", expr) }

sibilant <Node> = expr: (c / s !x / (j / z) !n !liquid) { new Node("sibilant", expr) }

consonant <Node> = expr: (voiced / unvoiced / syllabic) { new Node("consonant", expr) }

syllabic <Node> = expr: (l / m / n / r) { new Node("syllabic", expr) }

voiced <Node> = expr: (b / d / g / j / v / z) { new Node("voiced", expr) }

unvoiced <Node> = expr: (c / f / k / p / s / t / x) { new Node("unvoiced", expr) }

l <Node> = expr: (comma* [lL] !h !glide !l) { new Node("l", expr) }

m <Node> = expr: (comma* [mM] !h !glide !m !z) { new Node("m", expr) }

n <Node> = expr: (comma* [nN] !h !glide !n !affricate) { new Node("n", expr) }

r <Node> = expr: (comma* [rR] !h !glide !r) { new Node("r", expr) }

b <Node> = expr: (comma* [bB] !h !glide !b !unvoiced) { new Node("b", expr) }

d <Node> = expr: (comma* [dD] !h !glide !d !unvoiced) { new Node("d", expr) }

g <Node> = expr: (comma* [gG] !h !glide !g !unvoiced) { new Node("g", expr) }

v <Node> = expr: (comma* [vV] !h !glide !v !unvoiced) { new Node("v", expr) }

j <Node> = expr: (comma* [jJ] !h !glide !j !z !unvoiced) { new Node("j", expr) }

z <Node> = expr: (comma* [zZ] !h !glide !z !j !unvoiced) { new Node("z", expr) }

s <Node> = expr: (comma* [sS] !h !glide !s !c !voiced) { new Node("s", expr) }

c <Node> = expr: (comma* [cC] !h !glide !c !s !x !voiced) { new Node("c", expr) }

x <Node> = expr: (comma* [xX] !h !glide !x !c !k !voiced) { new Node("x", expr) }

k <Node> = expr: (comma* [kK] !h !glide !k !x !voiced) { new Node("k", expr) }

f <Node> = expr: (comma* [fF] !h !glide !f !voiced) { new Node("f", expr) }

p <Node> = expr: (comma* [pP] !h !glide !p !voiced) { new Node("p", expr) }

t <Node> = expr: (comma* [tT] !h !glide !t !voiced) { new Node("t", expr) }

h <Node> = expr: (comma* ['h] &nucleus) { new Node("h", expr) }

//___________________________________________________________________

digit <Node> = expr: (comma* [0123456789] !h !nucleus) { new Node("digit", expr) }

post_word <Node> = expr: (pause / !nucleus lojban_word) { new Node("post_word", expr) }

pause <Node> = expr: (comma* space_char+ / EOF) { new Node("pause", expr) }

EOF <Node> = expr: (comma* !.) { new Node("EOF", expr) }

comma <Node> = expr: ([,]) { new Node("comma", expr) }

// This is an orphan rule.
non_lojban_word <Node> = expr: (!lojban_word non_space+) { new Node("non_lojban_word", expr) }

non_space <Node> = expr: (!space_char .) { new Node("non_space", expr) }

//Unicode_style and escaped chars not compatible with cl_peg
space_char <Node> = expr: ([.\t\n\r?!\u0020]) { new Node("space_char", expr) }

// space_char = [.?! ] / space_char1 / space_char2
// space_char1 = '    '
// space_char2 = ''

//___________________________________________________________________

spaces <Node> = expr: (!Y initial_spaces) { new Node("spaces", expr) }

initial_spaces <Node> = expr: ((comma* space_char / !ybu Y)+ EOF? / EOF) { new Node("initial_spaces", expr) }

ybu <Node> = expr: (Y space_char* BU) { new Node("ybu", expr) }

lujvo <Node> = expr: (!gismu !fuhivla brivla) { new Node("lujvo", expr) }

//___________________________________________________________________

A <Node> = expr: (&cmavo ( a / e / j i / o / u ) &post_word) { new Node("A", expr) }

BAI <Node> = expr: (&cmavo ( d u h o / s i h u / z a u / k i h i / d u h i / c u h u / t u h i / t i h u / d i h o / j i h u / r i h a / n i h i / m u h i / k i h u / v a h u / k o i / c a h i / t a h i / p u h e / j a h i / k a i / b a i / f i h e / d e h i / c i h o / m a u / m u h u / r i h i / r a h i / k a h a / p a h u / p a h a / l e h a / k u h u / t a i / b a u / m a h i / c i h e / f a u / p o h i / c a u / m a h e / c i h u / r a h a / p u h a / l i h e / l a h u / b a h i / k a h i / s a u / f a h e / b e h i / t i h i / j a h e / g a h a / v a h o / j i h o / m e h a / d o h e / j i h e / p i h o / g a u / z u h e / m e h e / r a i ) &post_word) { new Node("BAI", expr) }

BAhE <Node> = expr: (&cmavo ( b a h e / z a h e ) &post_word) { new Node("BAhE", expr) }

BE <Node> = expr: (&cmavo ( b e ) &post_word) { new Node("BE", expr) }

BEI <Node> = expr: (&cmavo ( b e i ) &post_word) { new Node("BEI", expr) }

BEhO <Node> = expr: (&cmavo ( b e h o ) &post_word) { new Node("BEhO", expr) }

BIhE <Node> = expr: (&cmavo ( b i h e ) &post_word) { new Node("BIhE", expr) }

BIhI <Node> = expr: (&cmavo ( m i h i / b i h o / b i h i ) &post_word) { new Node("BIhI", expr) }

BO <Node> = expr: (&cmavo ( b o ) &post_word) { new Node("BO", expr) }

BOI <Node> = expr: (&cmavo ( b o i ) &post_word) { new Node("BOI", expr) }

BU <Node> = expr: (&cmavo ( b u ) &post_word) { new Node("BU", expr) }

BY <Node> = expr: (&cmavo ( ybu / j o h o / r u h o / g e h o / j e h o / l o h a / n a h a / s e h e / t o h a / g a h e / y h y / b y / c y / d y / f y / g y / j y / k y / l y / m y / n y / p y / r y / s y / t y / v y / x y / z y ) &post_word) { new Node("BY", expr) }

CAhA <Node> = expr: (&cmavo ( c a h a / p u h i / n u h o / k a h e ) &post_word) { new Node("CAhA", expr) }

CAI <Node> = expr: (&cmavo ( p e i / c a i / c u h i / s a i / r u h e ) &post_word) { new Node("CAI", expr) }

CEI <Node> = expr: (&cmavo ( c e i ) &post_word) { new Node("CEI", expr) }

CEhE <Node> = expr: (&cmavo ( c e h e ) &post_word) { new Node("CEhE", expr) }

CO <Node> = expr: (&cmavo ( c o ) &post_word) { new Node("CO", expr) }

COI <Node> = expr: (&cmavo ( j u h i / c o i / f i h i / t a h a / m u h o / f e h o / c o h o / p e h u / k e h o / n u h e / r e h i / b e h e / j e h e / m i h e / k i h e / v i h o ) &post_word) { new Node("COI", expr) }

CU <Node> = expr: (&cmavo ( c u ) &post_word) { new Node("CU", expr) }

CUhE <Node> = expr: (&cmavo ( c u h e / n a u ) &post_word) { new Node("CUhE", expr) }

DAhO <Node> = expr: (&cmavo ( d a h o ) &post_word) { new Node("DAhO", expr) }

DOI <Node> = expr: (&cmavo ( d o i ) &post_word) { new Node("DOI", expr) }

DOhU <Node> = expr: (&cmavo ( d o h u ) &post_word) { new Node("DOhU", expr) }

FA <Node> = expr: (&cmavo ( f a i / f a / f e / f o / f u / f i h a / f i ) &post_word) { new Node("FA", expr) }

FAhA <Node> = expr: (&cmavo ( d u h a / b e h a / n e h u / v u h a / g a h u / t i h a / n i h a / c a h u / z u h a / r i h u / r u h u / r e h o / t e h e / b u h u / n e h a / p a h o / n e h i / t o h o / z o h i / z e h o / z o h a / f a h a ) &post_word &post_word) { new Node("FAhA", expr) }

FAhO <Node> = expr: (&cmavo ( f a h o ) &post_word) { new Node("FAhO", expr) }

FEhE <Node> = expr: (&cmavo ( f e h e ) &post_word) { new Node("FEhE", expr) }

FEhU <Node> = expr: (&cmavo ( f e h u ) &post_word) { new Node("FEhU", expr) }

FIhO <Node> = expr: (&cmavo ( f i h o ) &post_word) { new Node("FIhO", expr) }

FOI <Node> = expr: (&cmavo ( f o i ) &post_word) { new Node("FOI", expr) }

FUhA <Node> = expr: (&cmavo ( f u h a ) &post_word) { new Node("FUhA", expr) }

FUhE <Node> = expr: (&cmavo ( f u h e ) &post_word) { new Node("FUhE", expr) }

FUhO <Node> = expr: (&cmavo ( f u h o ) &post_word) { new Node("FUhO", expr) }

GA <Node> = expr: (&cmavo ( g e h i / g e / g o / g a / g u ) &post_word) { new Node("GA", expr) }

GAhO <Node> = expr: (&cmavo ( k e h i / g a h o ) &post_word) { new Node("GAhO", expr) }

GEhU <Node> = expr: (&cmavo ( g e h u ) &post_word) { new Node("GEhU", expr) }

GI <Node> = expr: (&cmavo ( g i ) &post_word) { new Node("GI", expr) }

GIhA <Node> = expr: (&cmavo ( g i h e / g i h i / g i h o / g i h a / g i h u ) &post_word) { new Node("GIhA", expr) }

GOI <Node> = expr: (&cmavo ( n o h u / n e / g o i / p o h u / p e / p o h e / p o ) &post_word) { new Node("GOI", expr) }

GOhA <Node> = expr: (&cmavo ( m o / n e i / g o h u / g o h o / g o h i / n o h a / g o h e / g o h a / d u / b u h a / b u h e / b u h i / c o h e ) &post_word) { new Node("GOhA", expr) }

GUhA <Node> = expr: (&cmavo ( g u h e / g u h i / g u h o / g u h a / g u h u ) &post_word) { new Node("GUhA", expr) }

I <Node> = expr: (&cmavo ( i ) &post_word) { new Node("I", expr) }

JA <Node> = expr: (&cmavo ( j e h i / j e / j o / j a / j u ) &post_word) { new Node("JA", expr) }

JAI <Node> = expr: (&cmavo ( j a i ) &post_word) { new Node("JAI", expr) }

JOhI <Node> = expr: (&cmavo ( j o h i ) &post_word) { new Node("JOhI", expr) }

JOI <Node> = expr: (&cmavo ( f a h u / p i h u / j o i / c e h o / c e / j o h u / k u h a / j o h e / j u h e ) &post_word) { new Node("JOI", expr) }

KE <Node> = expr: (&cmavo ( k e ) &post_word) { new Node("KE", expr) }

KEhE <Node> = expr: (&cmavo ( k e h e ) &post_word) { new Node("KEhE", expr) }

KEI <Node> = expr: (&cmavo ( k e i ) &post_word) { new Node("KEI", expr) }

KI <Node> = expr: (&cmavo ( k i ) &post_word) { new Node("KI", expr) }

KOhA <Node> = expr: (&cmavo ( d a h u / d a h e / d i h u / d i h e / d e h u / d e h e / d e i / d o h i / m i h o / m a h a / m i h a / d o h o / k o h a / f o h u / k o h e / k o h i / k o h o / k o h u / f o h a / f o h e / f o h i / f o h o / v o h a / v o h e / v o h i / v o h o / v o h u / r u / r i / r a / t a / t u / t i / z i h o / k e h a / m a / z u h i / z o h e / c e h u / d a / d e / d i / k o / m i / d o ) &post_word) { new Node("KOhA", expr) }

KU <Node> = expr: (&cmavo ( k u ) &post_word) { new Node("KU", expr) }

KUhE <Node> = expr: (&cmavo ( k u h e ) &post_word) { new Node("KUhE", expr) }

KUhO <Node> = expr: (&cmavo ( k u h o ) &post_word) { new Node("KUhO", expr) }

LA <Node> = expr: (&cmavo ( l a i / l a h i / l a ) &post_word) { new Node("LA", expr) }

LAU <Node> = expr: (&cmavo ( c e h a / l a u / z a i / t a u ) &post_word) { new Node("LAU", expr) }

LAhE <Node> = expr: (&cmavo ( t u h a / l u h a / l u h o / l a h e / v u h i / l u h i / l u h e ) &post_word) { new Node("LAhE", expr) }

LE <Node> = expr: (&cmavo ( l e i / l o i / l e h i / l o h i / l e h e / l o h e / l o / l e ) &post_word) { new Node("LE", expr) }

LEhU <Node> = expr: (&cmavo ( l e h u ) &post_word) { new Node("LEhU", expr) }

LI <Node> = expr: (&cmavo ( m e h o / l i ) &post_word) { new Node("LI", expr) }

LIhU <Node> = expr: (&cmavo ( l i h u ) &post_word) { new Node("LIhU", expr) }

LOhO <Node> = expr: (&cmavo ( l o h o ) &post_word) { new Node("LOhO", expr) }

LOhU <Node> = expr: (&cmavo ( l o h u ) &post_word) { new Node("LOhU", expr) }

LU <Node> = expr: (&cmavo ( l u ) &post_word) { new Node("LU", expr) }

LUhU <Node> = expr: (&cmavo ( l u h u ) &post_word) { new Node("LUhU", expr) }

MAhO <Node> = expr: (&cmavo ( m a h o ) &post_word) { new Node("MAhO", expr) }

MAI <Node> = expr: (&cmavo ( m o h o / m a i ) &post_word) { new Node("MAI", expr) }

ME <Node> = expr: (&cmavo ( m e ) &post_word) { new Node("ME", expr) }

MEhU <Node> = expr: (&cmavo ( m e h u ) &post_word) { new Node("MEhU", expr) }

MOhE <Node> = expr: (&cmavo ( m o h e ) &post_word) { new Node("MOhE", expr) }

MOhI <Node> = expr: (&cmavo ( m o h i ) &post_word) { new Node("MOhI", expr) }

MOI <Node> = expr: (&cmavo ( m e i / m o i / s i h e / c u h o / v a h e ) &post_word) { new Node("MOI", expr) }

NA <Node> = expr: (&cmavo ( j a h a / n a ) &post_word) { new Node("NA", expr) }

NAI <Node> = expr: (&cmavo ( n a i ) &post_word) { new Node("NAI", expr) }

NAhE <Node> = expr: (&cmavo ( t o h e / j e h a / n a h e / n o h e ) &post_word) { new Node("NAhE", expr) }

NAhU <Node> = expr: (&cmavo ( n a h u ) &post_word) { new Node("NAhU", expr) }

NIhE <Node> = expr: (&cmavo ( n i h e ) &post_word) { new Node("NIhE", expr) }

NIhO <Node> = expr: (&cmavo ( n i h o / n o h i ) &post_word) { new Node("NIhO", expr) }

NOI <Node> = expr: (&cmavo ( v o i / n o i / p o i ) &post_word) { new Node("NOI", expr) }

NU <Node> = expr: (&cmavo ( n i / d u h u / s i h o / n u / l i h i / k a / j e i / s u h u / z u h o / m u h e / p u h u / z a h i ) &post_word) { new Node("NU", expr) }

NUhA <Node> = expr: (&cmavo ( n u h a ) &post_word) { new Node("NUhA", expr) }

NUhI <Node> = expr: (&cmavo ( n u h i ) &post_word) { new Node("NUhI", expr) }

NUhU <Node> = expr: (&cmavo ( n u h u ) &post_word) { new Node("NUhU", expr) }

PA <Node> = expr: (&cmavo ( d a u / f e i / g a i / j a u / r e i / v a i / p i h e / p i / f i h u / z a h u / m e h i / n i h u / k i h o / c e h i / m a h u / r a h e / d a h a / s o h a / j i h i / s u h o / s u h e / r o / r a u / s o h u / s o h i / s o h e / s o h o / m o h a / d u h e / t e h o / k a h o / c i h i / t u h o / x o / p a i / n o h o / n o / p a / r e / c i / v o / m u / x a / z e / b i / s o / digit ) &post_word) { new Node("PA", expr) }

PEhE <Node> = expr: (&cmavo ( p e h e ) &post_word) { new Node("PEhE", expr) }

PEhO <Node> = expr: (&cmavo ( p e h o ) &post_word) { new Node("PEhO", expr) }

PU <Node> = expr: (&cmavo ( b a / p u / c a ) &post_word) { new Node("PU", expr) }

RAhO <Node> = expr: (&cmavo ( r a h o ) &post_word) { new Node("RAhO", expr) }

ROI <Node> = expr: (&cmavo ( r e h u / r o i ) &post_word) { new Node("ROI", expr) }

SA <Node> = expr: (&cmavo ( s a ) &post_word) { new Node("SA", expr) }

SE <Node> = expr: (&cmavo ( s e / t e / v e / x e ) &post_word) { new Node("SE", expr) }

SEI <Node> = expr: (&cmavo ( s e i / t i h o ) &post_word) { new Node("SEI", expr) }

SEhU <Node> = expr: (&cmavo ( s e h u ) &post_word) { new Node("SEhU", expr) }

SI <Node> = expr: (&cmavo ( s i ) &post_word) { new Node("SI", expr) }

SOI <Node> = expr: (&cmavo ( s o i ) &post_word) { new Node("SOI", expr) }

SU <Node> = expr: (&cmavo ( s u ) &post_word) { new Node("SU", expr) }

TAhE <Node> = expr: (&cmavo ( r u h i / t a h e / d i h i / n a h o ) &post_word) { new Node("TAhE", expr) }

TEhU <Node> = expr: (&cmavo ( t e h u ) &post_word) { new Node("TEhU", expr) }

TEI <Node> = expr: (&cmavo ( t e i ) &post_word) { new Node("TEI", expr) }

TO <Node> = expr: (&cmavo ( t o h i / t o ) &post_word) { new Node("TO", expr) }

TOI <Node> = expr: (&cmavo ( t o i ) &post_word) { new Node("TOI", expr) }

TUhE <Node> = expr: (&cmavo ( t u h e ) &post_word) { new Node("TUhE", expr) }

TUhU <Node> = expr: (&cmavo ( t u h u ) &post_word) { new Node("TUhU", expr) }

UI <Node> = expr: (&cmavo ( i h a / i e / a h e / u h i / i h o / i h e / a h a / i a / o h i / o h e / e h e / o i / u o / e h i / u h o / a u / u a / a h i / i h u / i i / u h a / u i / a h o / a i / a h u / i u / e i / o h o / e h a / u u / o h a / o h u / u h u / e h o / i o / e h u / u e / i h i / u h e / b a h a / j a h o / c a h e / s u h a / t i h e / k a h u / s e h o / z a h a / p e h i / r u h a / j u h a / t a h o / r a h u / l i h a / b a h u / m u h a / d o h a / t o h u / v a h i / p a h e / z u h u / s a h e / l a h a / k e h u / s a h u / d a h i / j e h u / s a h a / k a u / t a h u / n a h i / j o h a / b i h u / l i h o / p a u / m i h u / k u h i / j i h a / s i h a / p o h o / p e h a / r o h i / r o h e / r o h o / r o h u / r o h a / r e h e / l e h o / j u h o / f u h i / d a i / g a h i / z o h o / b e h u / r i h e / s e h i / s e h a / v u h e / k i h a / x u / g e h e / b u h o ) &post_word) { new Node("UI", expr) }

VA <Node> = expr: (&cmavo ( v i / v a / v u ) &post_word) { new Node("VA", expr) }

VAU <Node> = expr: (&cmavo ( v a u ) &post_word) { new Node("VAU", expr) }

VEI <Node> = expr: (&cmavo ( v e i ) &post_word) { new Node("VEI", expr) }

VEhO <Node> = expr: (&cmavo ( v e h o ) &post_word) { new Node("VEhO", expr) }

VUhU <Node> = expr: (&cmavo ( g e h a / f u h u / p i h i / f e h i / v u h u / s u h i / j u h u / g e i / p a h i / f a h i / t e h a / c u h a / v a h a / n e h o / d e h o / f e h a / s a h o / r e h a / r i h o / s a h i / p i h a / s i h i ) &post_word) { new Node("VUhU", expr) }

VEhA <Node> = expr: (&cmavo ( v e h u / v e h a / v e h i / v e h e ) &post_word) { new Node("VEhA", expr) }

VIhA <Node> = expr: (&cmavo ( v i h i / v i h a / v i h u / v i h e ) &post_word) { new Node("VIhA", expr) }

VUhO <Node> = expr: (&cmavo ( v u h o ) &post_word) { new Node("VUhO", expr) }

XI <Node> = expr: (&cmavo ( x i ) &post_word) { new Node("XI", expr) }

Y <Node> = expr: (&cmavo ( y+ ) &post_word) { new Node("Y", expr) }

ZAhO <Node> = expr: (&cmavo ( c o h i / p u h o / c o h u / m o h u / c a h o / c o h a / d e h a / b a h o / d i h a / z a h o ) &post_word) { new Node("ZAhO", expr) }

ZEhA <Node> = expr: (&cmavo ( z e h u / z e h a / z e h i / z e h e ) &post_word) { new Node("ZEhA", expr) }

ZEI <Node> = expr: (&cmavo ( z e i ) &post_word) { new Node("ZEI", expr) }

ZI <Node> = expr: (&cmavo ( z u / z a / z i ) &post_word) { new Node("ZI", expr) }

ZIhE <Node> = expr: (&cmavo ( z i h e ) &post_word) { new Node("ZIhE", expr) }

ZO <Node> = expr: (&cmavo ( z o ) &post_word) { new Node("ZO", expr) }

ZOI <Node> = expr: (&cmavo ( z o i / l a h o ) &post_word) { new Node("ZOI", expr) }

ZOhU <Node> = expr: (&cmavo ( z o h u ) &post_word) { new Node("ZOhU", expr) }



